#include "tr_local.h"

const char *fallbackShader_bokeh_fp =
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4      u_Color;\n"
"\n"
"uniform vec2      u_InvTexRes;\n"
"varying vec2      var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color;\n"
"\tvec2 tc;\n"
"\n"
"#if 0\n"
"\tfloat c[7] = float[7](1.0, 0.9659258263, 0.8660254038, 0.7071067812, 0.5, 0.2588190451, 0.0);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[6]);  color =  texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[6],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[6], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[6]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\t\n"
"\tgl_FragColor = color * 0.04166667 * u_Color;\n"
"#endif\n"
"\n"
"\tfloat c[5] = float[5](1.0, 0.9238795325, 0.7071067812, 0.3826834324, 0.0);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[4]);  color =  texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\t\n"
"\tgl_FragColor = color * 0.0625 * u_Color;\n"
"}\n"
;
const char *fallbackShader_bokeh_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_TexCoords = attr_TexCoord0.st;\n"
"}\n"
;
const char *fallbackShader_calclevels4x_fp =
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4      u_Color;\n"
"\n"
"uniform vec2      u_InvTexRes;\n"
"varying vec2      var_TexCoords;\n"
"\n"
"const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 GetValues(vec2 offset, vec3 current)\n"
"{\n"
"\tvec3 minAvgMax;\n"
"\tvec2 tc = var_TexCoords + u_InvTexRes * offset; minAvgMax = texture2D(u_TextureMap, tc).rgb;\n"
"\n"
"#ifdef FIRST_PASS\n"
"\tfloat lumi = max(dot(LUMINANCE_VECTOR, minAvgMax), 0.000001);\n"
"\tfloat loglumi = clamp(log2(lumi), -10.0, 10.0);\n"
"\tminAvgMax = vec3(loglumi * 0.05 + 0.5);\n"
"#endif\n"
"\n"
"\treturn vec3(min(current.x, minAvgMax.x), current.y + minAvgMax.y, max(current.z, minAvgMax.z));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tvec3 current = vec3(1.0, 0.0, 0.0);\n"
"\n"
"#ifdef FIRST_PASS\n"
"\tcurrent = GetValues(vec2( 0.0,  0.0), current);\n"
"#else\n"
"\tcurrent = GetValues(vec2(-1.5, -1.5), current);\n"
"\tcurrent = GetValues(vec2(-0.5, -1.5), current);\n"
"\tcurrent = GetValues(vec2( 0.5, -1.5), current);\n"
"\tcurrent = GetValues(vec2( 1.5, -1.5), current);\n"
"\t\n"
"\tcurrent = GetValues(vec2(-1.5, -0.5), current);\n"
"\tcurrent = GetValues(vec2(-0.5, -0.5), current);\n"
"\tcurrent = GetValues(vec2( 0.5, -0.5), current);\n"
"\tcurrent = GetValues(vec2( 1.5, -0.5), current);\n"
"\t\n"
"\tcurrent = GetValues(vec2(-1.5,  0.5), current);\n"
"\tcurrent = GetValues(vec2(-0.5,  0.5), current);\n"
"\tcurrent = GetValues(vec2( 0.5,  0.5), current);\n"
"\tcurrent = GetValues(vec2( 1.5,  0.5), current);\n"
"\n"
"\tcurrent = GetValues(vec2(-1.5,  1.5), current);\n"
"\tcurrent = GetValues(vec2(-0.5,  1.5), current);\n"
"\tcurrent = GetValues(vec2( 0.5,  1.5), current);\n"
"\tcurrent = GetValues(vec2( 1.5,  1.5), current);\n"
"\n"
"\tcurrent.y *= 0.0625;\n"
"#endif\n"
"\n"
"\tgl_FragColor = vec4(current, 1.0f);\n"
"}\n"
;
const char *fallbackShader_calclevels4x_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_TexCoords = attr_TexCoord0.st;\n"
"}\n"
;
const char *fallbackShader_depthblur_fp =
"uniform sampler2D u_ScreenImageMap;\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform vec4   u_ViewInfo; // zfar / znear, zfar\n"
"varying vec2   var_ScreenTex;\n"
"\n"
"//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024, 0.0033);\n"
"float gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);\n"
"//float gauss[3] = float[3](0.60, 0.19, 0.0066);\n"
"#define GAUSS_SIZE 4\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"\t\tfloat sampleZDivW = texture2D(depthMap, tex).r;\n"
"\t\treturn 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"vec4 depthGaussian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar)\n"
"{\n"
"\tfloat scale = 1.0 / 256.0;\n"
"\n"
"#if defined(USE_HORIZONTAL_BLUR)\n"
"    vec2 direction = vec2(1.0, 0.0) * scale;\n"
"#else // if defined(USE_VERTICAL_BLUR)\n"
"\tvec2 direction = vec2(0.0, 1.0) * scale;\n"
"#endif\n"
"\t\n"
"\tfloat depthCenter = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"\tvec2 centerSlope = vec2(dFdx(depthCenter), dFdy(depthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"\t\t\n"
"\tvec4 result = texture2D(imageMap, tex) * gauss[0];\n"
"\tfloat total = gauss[0];\n"
"\n"
"\tint i, j;\n"
"\tfor (i = 0; i < 2; i++)\n"
"\t{\n"
"\t\tfor (j = 1; j < GAUSS_SIZE; j++)\n"
"\t\t{\n"
"\t\t\tvec2 offset = direction * j;\n"
"\t\t\tfloat depthSample = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"\t\t\tfloat depthExpected = depthCenter + dot(centerSlope, offset);\n"
"\t\t\tif(abs(depthSample - depthExpected) < 5.0)\n"
"\t\t\t{\n"
"\t\t\t\tresult += texture2D(imageMap, tex + offset) * gauss[j];\n"
"\t\t\t\ttotal += gauss[j];\n"
"\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\tdirection = -direction;\n"
"\t}\t\n"
"\t\t\n"
"\treturn result / total;\n"
"}\n"
"\n"
"void main()\n"
"{\t\t\n"
"\tgl_FragColor = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);\n"
"}\n"
;
const char *fallbackShader_depthblur_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"varying vec2   var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = attr_Position;\n"
"\tvar_ScreenTex = attr_TexCoord0.xy;\n"
"\t//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"\t//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;
const char *fallbackShader_dlight_fp =
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"varying vec2      var_Tex1;\n"
"varying vec4      var_Color;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color = texture2D(u_DiffuseMap, var_Tex1);\n"
"\n"
"\tgl_FragColor = color * var_Color;\n"
"}\n"
;
const char *fallbackShader_dlight_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"attribute vec3 attr_Normal;\n"
"\n"
"uniform vec4   u_DlightInfo;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int    u_DeformGen;\n"
"uniform float  u_DeformParams[5];\n"
"uniform float  u_Time;\n"
"#endif\n"
"\n"
"uniform vec4   u_Color;\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_Tex1;\n"
"varying vec4   var_Color;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"\tif (u_DeformGen == 0)\n"
"\t{\n"
"\t\treturn pos;\n"
"\t}\n"
"\n"
"\tfloat base =      u_DeformParams[0];\n"
"\tfloat amplitude = u_DeformParams[1];\n"
"\tfloat phase =     u_DeformParams[2];\n"
"\tfloat frequency = u_DeformParams[3];\n"
"\tfloat spread =    u_DeformParams[4];\n"
"\n"
"\tif (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tphase *= M_PI * 0.25 * st.x;\n"
"\t}\n"
"\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tphase += dot(pos.xyz, vec3(spread));\n"
"\t}\n"
"\n"
"\tfloat value = phase + (u_Time * frequency);\n"
"\tfloat func;\n"
"\n"
"\tif (u_DeformGen == DGEN_WAVE_SIN)\n"
"\t{\n"
"\t\tfunc = sin(value * 2.0 * M_PI);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SQUARE)\n"
"\t{\n"
"\t\tfunc = sign(sin(value * 2.0 * M_PI));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\n"
"\t{\n"
"\t\tfunc = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = fract(value);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = (1.0 - fract(value));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tfunc = sin(value);\n"
"\t}\n"
"\n"
"\treturn pos + normal * (base + func * amplitude);\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 position = attr_Position;\n"
"\tvec3 normal = attr_Normal;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"\tposition.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);\n"
"#endif\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\t\t\n"
"\tvec3 dist = u_DlightInfo.xyz - position.xyz;\t\n"
"\n"
"\tvar_Tex1 = dist.xy * u_DlightInfo.a + vec2(0.5);\n"
"\tfloat dlightmod = step(0.0, dot(dist, normal));\n"
"\tdlightmod *= clamp(2.0 * (1.0 - abs(dist.z) * u_DlightInfo.a), 0.0, 1.0);\n"
"\t\n"
"\tvar_Color = u_Color * dlightmod;\n"
"}\n"
;
const char *fallbackShader_down4x_fp =
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec2      u_InvTexRes;\n"
"varying vec2      var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color;\n"
"\tvec2 tc;\n"
"\t\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-1.5, -1.5);  color  = texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\t\n"
"\tcolor *= 0.0625;\n"
"\t\n"
"\tgl_FragColor = color;\n"
"}\n"
;
const char *fallbackShader_down4x_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_TexCoords = attr_TexCoord0.st;\n"
"}\n"
;
const char *fallbackShader_fogpass_fp =
"uniform vec4  u_Color;\n"
"\n"
"varying float var_Scale;\n"
"\n"
"void main()\n"
"{\n"
"\tgl_FragColor = u_Color;\n"
"\tgl_FragColor.a *= sqrt(clamp(var_Scale, 0.0, 1.0));\n"
"}\n"
;
const char *fallbackShader_fogpass_vp =
"attribute vec4  attr_Position;\n"
"attribute vec3  attr_Normal;\n"
"attribute vec4  attr_TexCoord0;\n"
"\n"
"//#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec4  attr_Position2;\n"
"attribute vec3  attr_Normal2;\n"
"//#endif\n"
"\n"
"uniform vec4    u_FogDistance;\n"
"uniform vec4    u_FogDepth;\n"
"uniform float   u_FogEyeT;\n"
"\n"
"//#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int     u_DeformGen;\n"
"uniform float   u_DeformParams[5];\n"
"//#endif\n"
"\n"
"uniform float   u_Time;\n"
"uniform mat4    u_ModelViewProjectionMatrix;\n"
"\n"
"//#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float   u_VertexLerp;\n"
"//#endif\n"
"\n"
"varying float   var_Scale;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"\tif (u_DeformGen == 0)\n"
"\t{\n"
"\t\treturn pos;\n"
"\t}\n"
"\n"
"\tfloat base =      u_DeformParams[0];\n"
"\tfloat amplitude = u_DeformParams[1];\n"
"\tfloat phase =     u_DeformParams[2];\n"
"\tfloat frequency = u_DeformParams[3];\n"
"\tfloat spread =    u_DeformParams[4];\n"
"\n"
"\tif (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tphase *= M_PI * 0.25 * st.x;\n"
"\t}\n"
"\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tphase += dot(pos.xyz, vec3(spread));\n"
"\t}\n"
"\n"
"\tfloat value = phase + (u_Time * frequency);\n"
"\tfloat func;\n"
"\n"
"\tif (u_DeformGen == DGEN_WAVE_SIN)\n"
"\t{\n"
"\t\tfunc = sin(value * 2.0 * M_PI);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SQUARE)\n"
"\t{\n"
"\t\tfunc = sign(sin(value * 2.0 * M_PI));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\n"
"\t{\n"
"\t\tfunc = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = fract(value);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = (1.0 - fract(value));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tfunc = sin(value);\n"
"\t}\n"
"\n"
"\treturn pos + normal * (base + func * amplitude);\n"
"}\n"
"#endif\n"
"\n"
"float CalcFog(vec4 position)\n"
"{\n"
"\tfloat s = dot(position, u_FogDistance) * 8.0;\n"
"\tfloat t = dot(position, u_FogDepth);\n"
"\n"
"\tif (t < 1.0)\n"
"\t{\n"
"\t\tt = step(step(0.0, -u_FogEyeT), t);\n"
"\t}\n"
"\telse\n"
"\t{\n"
"\t\tt /= t - min(u_FogEyeT, 0.0);\n"
"\t}\n"
"\t\n"
"\treturn s * t;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"\tvec4 position = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"\tvec3 normal = normalize(mix(attr_Normal, attr_Normal2, u_VertexLerp));\n"
"#else\n"
"\tvec4 position = attr_Position;\n"
"\tvec3 normal = attr_Normal;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"\tposition.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);\n"
"#endif\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\n"
"\tvar_Scale = CalcFog(position);\n"
"}\n"
;
const char *fallbackShader_generic_fp =
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"\n"
"uniform int       u_Texture1Env;\n"
"#endif\n"
"\n"
"varying vec2      var_DiffuseTex;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"varying vec2      var_LightTex;\n"
"#endif\n"
"\n"
"varying vec4      var_Color;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color  = texture2D(u_DiffuseMap, var_DiffuseTex);\n"
"#if defined(USE_LIGHTMAP)\n"
"\tvec4 color2 = texture2D(u_LightMap, var_LightTex);\n"
"  #if defined(RGBE_LIGHTMAP)\n"
"\tcolor2.rgb *= exp2(color2.a * 255.0 - 128.0);\n"
"\tcolor2.a = 1.0;\n"
"  #endif\n"
"\n"
"\tif (u_Texture1Env == TEXENV_MODULATE)\n"
"\t{\n"
"\t\tcolor *= color2;\n"
"\t}\n"
"\telse if (u_Texture1Env == TEXENV_ADD)\n"
"\t{\n"
"\t\tcolor += color2;\n"
"\t}\n"
"\telse if (u_Texture1Env == TEXENV_REPLACE)\n"
"\t{\n"
"\t\tcolor = color2;\n"
"\t}\n"
"#endif\n"
"\n"
"\tgl_FragColor = color * var_Color;\n"
"}\n"
;
const char *fallbackShader_generic_vp =
"attribute vec4 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec4 attr_Position2;\n"
"attribute vec3 attr_Normal2;\n"
"#endif\n"
"\n"
"attribute vec4 attr_Color;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)\n"
"attribute vec4 attr_TexCoord1;\n"
"#endif\n"
"\n"
"uniform vec4   u_DiffuseTexMatrix;\n"
"uniform vec4   u_DiffuseTexOffTurb;\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_RGBAGEN)\n"
"uniform vec3   u_ViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int    u_TCGen0;\n"
"uniform vec3   u_TCGen0Vector0;\n"
"uniform vec3   u_TCGen0Vector1;\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"uniform vec4   u_FogDistance;\n"
"uniform vec4   u_FogDepth;\n"
"uniform float  u_FogEyeT;\n"
"uniform vec4   u_FogColorMask;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int    u_DeformGen;\n"
"uniform float  u_DeformParams[5];\n"
"uniform float  u_Time;\n"
"#endif\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"uniform vec4   u_BaseColor;\n"
"uniform vec4   u_VertColor;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int    u_ColorGen;\n"
"uniform int    u_AlphaGen;\n"
"uniform vec3   u_AmbientLight;\n"
"uniform vec3   u_DirectedLight;\n"
"uniform vec4   u_LightOrigin;\n"
"uniform float  u_PortalRange;\n"
"#endif\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float  u_VertexLerp;\n"
"#endif\n"
"\n"
"varying vec2   var_DiffuseTex;\n"
"#if defined(USE_LIGHTMAP)\n"
"varying vec2   var_LightTex;\n"
"#endif\n"
"varying vec4   var_Color;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"\tfloat base =      u_DeformParams[0];\n"
"\tfloat amplitude = u_DeformParams[1];\n"
"\tfloat phase =     u_DeformParams[2];\n"
"\tfloat frequency = u_DeformParams[3];\n"
"\tfloat spread =    u_DeformParams[4];\n"
"\n"
"\tif (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tphase *= M_PI * 0.25 * st.x;\n"
"\t}\n"
"\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tphase += dot(pos.xyz, vec3(spread));\n"
"\t}\n"
"\n"
"\tfloat value = phase + (u_Time * frequency);\n"
"\tfloat func;\n"
"\n"
"\tif (u_DeformGen == DGEN_WAVE_SIN)\n"
"\t{\n"
"\t\tfunc = sin(value * 2.0 * M_PI);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SQUARE)\n"
"\t{\n"
"\t\tfunc = sign(sin(value * 2.0 * M_PI));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\n"
"\t{\n"
"\t\tfunc = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = fract(value);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = (1.0 - fract(value));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tfunc = sin(value);\n"
"\t}\n"
"\n"
"\treturn pos + normal * (base + func * amplitude);\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"\tvec2 tex = attr_TexCoord0.st;\n"
"\n"
"\tif (TCGen == TCGEN_LIGHTMAP)\n"
"\t{\n"
"\t\ttex = attr_TexCoord1.st;\n"
"\t}\n"
"\telse if (TCGen == TCGEN_ENVIRONMENT_MAPPED)\n"
"\t{\n"
"\t\tvec3 viewer = normalize(u_ViewOrigin - position);\n"
"\t\ttex = -reflect(viewer, normal).yz * vec2(0.5, -0.5) + 0.5;\n"
"\t}\n"
"\telse if (TCGen == TCGEN_VECTOR)\n"
"\t{\n"
"\t\ttex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"\t}\n"
"\t\n"
"\treturn tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"\tfloat amplitude = offTurb.z;\n"
"\tfloat phase = offTurb.w;\n"
"\tvec2 st2 = vec2(dot(st, texMatrix.xz), dot(st, texMatrix.yw)) + offTurb.xy;\n"
"\n"
"\tvec3 offsetPos = position / 1024.0;\n"
"\toffsetPos.x += offsetPos.z;\n"
"\t\n"
"\tvec2 texOffset = sin((offsetPos.xy + vec2(phase)) * 2.0 * M_PI);\n"
"\t\n"
"\treturn st2 + texOffset * amplitude;\t\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"\tvec4 color = u_VertColor * attr_Color + u_BaseColor;\n"
"\t\n"
"\tif (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"\t{\n"
"\t\tfloat incoming = clamp(dot(normal, u_LightOrigin.xyz), 0.0, 1.0);\n"
"\n"
"\t\tcolor.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"\t}\n"
"\t\n"
"\tvec3 toView = u_ViewOrigin - position;\n"
"\tvec3 viewer = normalize(u_ViewOrigin - position);\n"
"\n"
"\tif (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"\t{\n"
"\t\tvec3 lightDir = normalize(vec3(-960.0, -1980.0, 96.0) - position.xyz);\n"
"\t\tvec3 halfangle = normalize(lightDir + viewer);\n"
"\t\t\n"
"\t\tcolor.a = pow(max(dot(normal, halfangle), 0.0), 8.0);\n"
"\t}\n"
"\telse if (u_AlphaGen == AGEN_PORTAL)\n"
"\t{\n"
"\t\tfloat alpha = length(toView) / u_PortalRange;\n"
"\n"
"\t\tcolor.a = clamp(alpha, 0.0, 1.0);\n"
"\t}\n"
"\telse if (u_AlphaGen == AGEN_FRESNEL)\n"
"\t{\n"
"\t\tcolor.a = 0.10 + 0.90 * pow(1.0 - dot(normal, viewer), 5);\n"
"\t}\n"
"\t\n"
"\treturn color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"float CalcFog(vec4 position)\n"
"{\n"
"\tfloat s = dot(position, u_FogDistance) * 8.0;\n"
"\tfloat t = dot(position, u_FogDepth);\n"
"\n"
"\tif (t < 1.0)\n"
"\t{\n"
"\t\tt = step(step(0.0, -u_FogEyeT), t);\n"
"\t}\n"
"\telse\n"
"\t{\n"
"\t\tt /= t - min(u_FogEyeT, 0.0);\n"
"\t}\n"
"\n"
"\treturn s * t;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"\tvec4 position = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"\tvec3 normal = normalize(mix(attr_Normal, attr_Normal2, u_VertexLerp));\n"
"#else\n"
"\tvec4 position = attr_Position;\n"
"\tvec3 normal = attr_Normal;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"\tposition.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);\n"
"#endif\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\n"
"#if defined(USE_TCGEN)\n"
"\tvec2 tex = GenTexCoords(u_TCGen0, position.xyz, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"\tvec2 tex = attr_TexCoord0.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"\tvar_DiffuseTex = ModTexCoords(tex, position.xyz, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"    var_DiffuseTex = tex;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"\tvar_LightTex = attr_TexCoord1.st;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"\tvar_Color = CalcColor(position.xyz, normal);\n"
"#else\n"
"\tvar_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"\tvar_Color *= vec4(1.0) - u_FogColorMask * sqrt(clamp(CalcFog(position), 0.0, 1.0));\n"
"#endif\n"
"}\n"
;
const char *fallbackShader_lightall_fp =
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform sampler2D u_DeluxeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"uniform vec3      u_ViewOrigin;\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int    u_TCGen0;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"uniform vec4      u_LightOrigin;\n"
"uniform vec3      u_DirectedLight;\n"
"uniform vec3      u_AmbientLight;\n"
"uniform float     u_LightRadius;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec3  u_PrimaryLightColor;\n"
"uniform vec3  u_PrimaryLightAmbient;\n"
"uniform float u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"\n"
"#if defined(USE_LIGHT)\n"
"uniform vec2      u_MaterialInfo;\n"
"#endif\n"
"\n"
"varying vec2      var_DiffuseTex;\n"
"#if defined(USE_LIGHTMAP)\n"
"varying vec2      var_LightTex;\n"
"#endif\n"
"varying vec4      var_Color;\n"
"\n"
"#if defined(USE_NORMALMAP) && !defined(USE_VERT_TANGENT_SPACE)\n"
"varying vec3      var_Position;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"varying vec3      var_SampleToView;\n"
"#endif\n"
"\n"
"#if !defined(USE_FAST_LIGHT)\n"
"varying vec3      var_Normal;\n"
"#endif\n"
"\n"
"#if defined(USE_VERT_TANGENT_SPACE)\n"
"varying vec3      var_Tangent;\n"
"varying vec3      var_Bitangent;\n"
"#endif\n"
"\n"
"varying vec3      var_VertLight;\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_DELUXEMAP)\n"
"varying vec3      var_LightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"varying vec3      var_PrimaryLightDirection;\n"
"#endif\n"
"\n"
"\n"
"#define EPSILON 0.00000001\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"float SampleHeight(sampler2D normalMap, vec2 t)\n"
"{\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"\treturn texture2D(normalMap, t).r;\n"
"  #else\n"
"\treturn texture2D(normalMap, t).a;\n"
"  #endif\n"
"}\n"
"\n"
"float RayIntersectDisplaceMap(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"\tconst int linearSearchSteps = 16;\n"
"\tconst int binarySearchSteps = 6;\n"
"\n"
"\tfloat depthStep = 1.0 / float(linearSearchSteps);\n"
"\n"
"\t// current size of search window\n"
"\tfloat size = depthStep;\n"
"\n"
"\t// current depth position\n"
"\tfloat depth = 0.0;\n"
"\n"
"\t// best match found (starts with last position 1.0)\n"
"\tfloat bestDepth = 1.0;\n"
"\n"
"\t// search front to back for first point inside object\n"
"\tfor(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"\t{\n"
"\t\tdepth += size;\n"
"\t\t\n"
"\t\tfloat t = 1.0 - SampleHeight(normalMap, dp + ds * depth);\n"
"\t\t\n"
"\t\tif(bestDepth > 0.996)\t\t// if no depth found yet\n"
"\t\t\tif(depth >= t)\n"
"\t\t\t\tbestDepth = depth;\t// store best depth\n"
"\t}\n"
"\n"
"\tdepth = bestDepth;\n"
"\t\n"
"\t// recurse around first point (depth) for closest match\n"
"\tfor(int i = 0; i < binarySearchSteps; ++i)\n"
"\t{\n"
"\t\tsize *= 0.5;\n"
"\n"
"\t\tfloat t = 1.0 - SampleHeight(normalMap, dp + ds * depth);\n"
"\t\t\n"
"\t\tif(depth >= t)\n"
"\t\t{\n"
"\t\t\tbestDepth = depth;\n"
"\t\t\tdepth -= 2.0 * size;\n"
"\t\t}\n"
"\n"
"\t\tdepth += size;\n"
"\t}\n"
"\n"
"\treturn bestDepth;\n"
"}\n"
"#endif\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, vec3 N, vec3 L, vec3 E, float NE, float NL, float shininess)\n"
"{\n"
"  #if defined(USE_OREN_NAYAR) || defined(USE_TRIACE_OREN_NAYAR)\n"
"\tfloat gamma = dot(E, L) - NE * NL;\n"
"\tfloat B = 2.22222 + 0.1 * shininess;\n"
"\t\t\n"
"    #if defined(USE_OREN_NAYAR)\n"
"\tfloat A = 1.0 - 1.0 / (2.0 + 0.33 * shininess);\n"
"\tgamma = clamp(gamma, 0.0, 1.0);\n"
"    #endif\n"
"\t\n"
"    #if defined(USE_TRIACE_OREN_NAYAR)\n"
"\tfloat A = 1.0 - 1.0 / (2.0 + 0.65 * shininess);\n"
"\n"
"\tif (gamma >= 0.0)\n"
"    #endif\n"
"\t{\n"
"\t\tB *= max(max(NL, NE), EPSILON);\n"
"\t}\n"
"\n"
"\treturn diffuseAlbedo * (A + gamma / B);\n"
"  #else\n"
"\treturn diffuseAlbedo;\n"
"  #endif\n"
"}\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"vec3 CalcSpecular(vec3 specularReflectance, float NH, float NL, float NE, float EH, float shininess)\n"
"{\n"
"  #if defined(USE_BLINN) || defined(USE_TRIACE) || defined(USE_TORRANCE_SPARROW)\n"
"\tfloat blinn = pow(NH, shininess);\n"
"  #endif\n"
"\n"
"  #if defined(USE_BLINN)\n"
"\treturn specularReflectance * blinn;\n"
"  #endif\n"
"\n"
"  #if defined(USE_COOK_TORRANCE) || defined (USE_TRIACE) || defined (USE_TORRANCE_SPARROW)\n"
"\tvec3 fresnel = specularReflectance + (vec3(1.0) - specularReflectance) * pow(1.0 - EH, 5);\n"
"  #endif\n"
"\n"
"  #if defined(USE_COOK_TORRANCE) || defined(USE_TORRANCE_SPARROW)\n"
"\tfloat geo = 2.0 * NH * min(NE, NL);\n"
"\tgeo /= max(EH, geo);\n"
"  #endif  \n"
"\n"
"  #if defined(USE_COOK_TORRANCE)\n"
"\tfloat m_sq = 2.0 / max(shininess, EPSILON);\n"
"\tfloat NH_sq = NH * NH;\n"
"\tfloat m_NH_sq = m_sq * NH_sq;\n"
"\tfloat beckmann = exp((NH_sq - 1.0) / max(m_NH_sq, EPSILON)) / max(4.0 * m_NH_sq * NH_sq, EPSILON);\n"
"\n"
"\treturn fresnel * geo * beckmann / max(NE, EPSILON);\n"
"  #endif\n"
"\n"
"  #if defined(USE_TRIACE)\n"
"\tfloat scale = 0.1248582 * shininess + 0.2691817;\n"
"\n"
"\treturn fresnel * scale * blinn / max(max(NL, NE), EPSILON);\n"
"  #endif\n"
"  \n"
"  #if defined(USE_TORRANCE_SPARROW)\n"
"\tfloat scale = 0.125 * shininess + 1.0;\n"
"\n"
"\treturn fresnel * geo * scale * blinn / max(NE, EPSILON);\n"
"  #endif\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"#if !defined(USE_FAST_LIGHT) && (defined(USE_LIGHT) || defined(USE_NORMALMAP))\n"
"\tvec3 surfN = normalize(var_Normal);\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"\tvec3 L = 2.0 * texture2D(u_DeluxeMap, var_LightTex).xyz - vec3(1.0);\n"
"\t//L += var_LightDirection * 0.0001;\n"
"#elif defined(USE_LIGHT)\n"
"\tvec3 L = var_LightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"\tvec4 lightSample = texture2D(u_LightMap, var_LightTex).rgba;\n"
"  #if defined(RGBE_LIGHTMAP)\n"
"\tlightSample.rgb *= exp2(lightSample.a * 255.0 - 128.0);\n"
"  #endif\n"
"\tvec3 lightColor = lightSample.rgb;\n"
"#elif defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT)\n"
"  #if defined(USE_INVSQRLIGHT)\n"
"\tfloat intensity = 1.0 / dot(L, L);\n"
"  #else\n"
"\tfloat intensity = clamp((1.0 - dot(L, L) / (u_LightRadius * u_LightRadius)) * 1.07, 0.0, 1.0);\n"
"  #endif\n"
"\n"
"\tvec3 lightColor = u_DirectedLight * intensity;\n"
"\tvec3 ambientColor  = u_AmbientLight;\n"
"#elif defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)\n"
"\tvec3 lightColor = var_VertLight;\n"
"#endif\n"
"\t\n"
"#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"\tvec3 E = normalize(var_SampleToView);\n"
"#endif\n"
"\tvec2 texCoords = var_DiffuseTex;\n"
"\n"
"\tfloat ambientDiff = 1.0;\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"  #if defined(USE_VERT_TANGENT_SPACE)\n"
"\tmat3 tangentToWorld = mat3(var_Tangent, var_Bitangent, var_Normal);\n"
"  #else\n"
"\tvec3 q0  = dFdx(var_Position);\n"
"\tvec3 q1  = dFdy(var_Position);\n"
"\tvec2 st0 = dFdx(texCoords);\n"
"\tvec2 st1 = dFdy(texCoords);\n"
"\tfloat dir = sign(st1.t * st0.s - st0.t * st1.s);\n"
"\n"
"\tvec3   tangent =  normalize(q0 * st1.t - q1 * st0.t) * dir;\n"
"\tvec3 bitangent = -normalize(q0 * st1.s - q1 * st0.s) * dir;\n"
"\n"
"\tmat3 tangentToWorld = mat3(tangent, bitangent, var_Normal);\n"
"  #endif\n"
"\n"
"  #if defined(USE_PARALLAXMAP)\n"
"\tvec3 offsetDir = normalize(E * tangentToWorld);\n"
"\toffsetDir.xy *= -0.05 / offsetDir.z;\n"
"\n"
"\ttexCoords += offsetDir.xy * RayIntersectDisplaceMap(texCoords, offsetDir.xy, u_NormalMap);\n"
"  #endif\n"
"\tvec3 texN;\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"\ttexN.xy = 2.0 * texture2D(u_NormalMap, texCoords).ag - 1.0;\n"
"  #else\n"
"\ttexN.xy = 2.0 * texture2D(u_NormalMap, texCoords).rg - 1.0;\n"
"  #endif\n"
"\ttexN.z = sqrt(clamp(1.0 - dot(texN.xy, texN.xy), 0.0, 1.0));\n"
"\tvec3 N = tangentToWorld * texN;\n"
"  #if defined(r_normalAmbient)\n"
"\tambientDiff = 0.781341 * texN.z + 0.218659;\n"
"  #endif\n"
"#elif defined(USE_LIGHT) && !defined(USE_FAST_LIGHT) \n"
"\tvec3 N = surfN;\n"
"#endif\n"
"\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || (defined(USE_TCGEN) && defined(USE_NORMALMAP))\n"
"\tN = normalize(N);\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) && defined(USE_NORMALMAP)\n"
"\tif (u_TCGen0 == TCGEN_ENVIRONMENT_MAPPED)\n"
"\t{\n"
"\t\ttexCoords = -reflect(E, N).yz * vec2(0.5, -0.5) + 0.5;\n"
"\t}\n"
"#endif\n"
"\n"
"\tvec4 diffuseAlbedo = texture2D(u_DiffuseMap, texCoords);\n"
"#if defined(USE_LIGHT) && defined(USE_GAMMA2_TEXTURES)\n"
"\tdiffuseAlbedo.rgb *= diffuseAlbedo.rgb;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && defined(USE_FAST_LIGHT)\n"
"\tgl_FragColor = diffuse.rgb;\n"
"  #if defined(USE_LIGHTMAP) \n"
"\tgl_FragColor *= lightColor;\n"
"  #endif\n"
"#elif defined(USE_LIGHT)\n"
"\tL = normalize(L);\n"
"\n"
"\tfloat surfNL = clamp(dot(surfN,  L),   0.0, 1.0);\n"
"\t\n"
"  #if defined(USE_SHADOWMAP) \n"
"\tvec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\n"
"\tfloat shadowValue = texture2D(u_ShadowMap, shadowTex).r;\n"
"\n"
"\t// surfaces not facing the light are always shadowed\n"
"\tshadowValue *= step(0.0, dot(surfN, var_PrimaryLightDirection));\n"
"  \n"
"    #if defined(SHADOWMAP_MODULATE)\n"
"\t//vec3 shadowColor = min(u_PrimaryLightAmbient, lightColor);\n"
"\tvec3 shadowColor = u_PrimaryLightAmbient * lightColor;\n"
"\n"
"      #if 0\n"
"\t// Only shadow when the world light is parallel to the primary light\n"
"\tshadowValue = 1.0 + (shadowValue - 1.0) * clamp(dot(L, var_PrimaryLightDirection), 0.0, 1.0);\n"
"      #endif\n"
"\tlightColor = mix(shadowColor, lightColor, shadowValue);\n"
"    #endif\n"
"  #endif\n"
"\n"
"  #if defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)\n"
"    #if defined(USE_STANDARD_DELUXEMAP)\n"
"\t// Standard deluxe mapping treats the light sample as fully directed\n"
"\t// and doesn't compensate for light angle attenuation.\n"
"\tvec3 ambientColor = vec3(0.0);\n"
"    #else\n"
"\t// Separate the light sample into directed and ambient parts.\n"
"\t//\n"
"\t// ambientMax  - if the cosine of the angle between the surface\n"
"\t//               normal and the light is below this value, the light\n"
"\t//               is fully ambient.\n"
"\t// directedMax - if the cosine of the angle between the surface\n"
"\t//               normal and the light is above this value, the light\n"
"\t//               is fully directed.\n"
"\tconst float ambientMax  = 0.25;\n"
"\tconst float directedMax = 0.5;\n"
"\n"
"\tfloat directedScale = clamp((surfNL - ambientMax) / (directedMax - ambientMax), 0.0, 1.0);\n"
"\t\n"
"\t// Scale the directed portion to compensate for the baked-in\n"
"\t// light angle attenuation.\n"
"\tdirectedScale /= max(surfNL, ambientMax);\n"
"\t\n"
"      #if defined(r_normalAmbient)\n"
"\tdirectedScale *= 1.0 - r_normalAmbient;\n"
"      #endif\n"
"\n"
"\t// Recover any unused light as ambient\n"
"\tvec3 ambientColor = lightColor;\n"
"\tlightColor *= directedScale;\n"
"\tambientColor -= lightColor * surfNL;\n"
"    #endif\n"
"  #endif\n"
"\n"
"\tfloat NL = clamp(dot(N, L), 0.0, 1.0);\n"
"\tfloat NE = clamp(dot(N, E), 0.0, 1.0);\n"
"\n"
"\tfloat maxReflectance = u_MaterialInfo.x;\n"
"\tfloat shininess = u_MaterialInfo.y;\n"
"\n"
"  #if defined(USE_SPECULARMAP)\n"
"\tvec4 specularReflectance = texture2D(u_SpecularMap, texCoords);\n"
"\tspecularReflectance.rgb *= maxReflectance;\n"
"\tshininess *= specularReflectance.a;\n"
"\t// adjust diffuse by specular reflectance, to maintain energy conservation\n"
"\tdiffuseAlbedo.rgb *= vec3(1.0) - specularReflectance.rgb;\n"
"  #endif\n"
"\n"
"\tgl_FragColor.rgb = lightColor * NL * CalcDiffuse(diffuseAlbedo.rgb, N, L, E, NE, NL, shininess);\n"
"\tgl_FragColor.rgb += ambientDiff * ambientColor * diffuseAlbedo.rgb;\n"
"  #if defined(USE_PRIMARY_LIGHT)\n"
"\tvec3 L2 = var_PrimaryLightDirection;\n"
"\tfloat NL2 = clamp(dot(N, L2), 0.0, 1.0);\n"
"\n"
"    #if defined(USE_SHADOWMAP)\n"
"\tgl_FragColor.rgb += u_PrimaryLightColor * shadowValue * NL2 * CalcDiffuse(diffuseAlbedo.rgb, N, L2, E, NE, NL2, shininess);\n"
"    #else\n"
"\tgl_FragColor.rgb += u_PrimaryLightColor * NL2 * CalcDiffuse(diffuseAlbedo.rgb, N, L2, E, NE, NL2, shininess);\n"
"    #endif\n"
"  #endif\n"
"  \n"
"  #if defined(USE_SPECULARMAP)\n"
"\tvec3 H = normalize(L + E);\n"
"\n"
"\tfloat EH = clamp(dot(E, H), 0.0, 1.0);\n"
"\tfloat NH = clamp(dot(N, H), 0.0, 1.0);\n"
"\n"
"\tgl_FragColor.rgb += lightColor * NL * CalcSpecular(specularReflectance.rgb, NH, NL, NE, EH, shininess);\n"
"  \n"
"    #if defined(r_normalAmbient)\n"
"\tvec3 ambientHalf = normalize(surfN + E);\n"
"\tfloat ambientSpec = max(dot(ambientHalf, N) + 0.5, 0.0);\n"
"\tambientSpec *= ambientSpec * 0.44;\n"
"\tgl_FragColor.rgb += specularReflectance.rgb * ambientSpec * ambientColor;\n"
"    #endif\n"
"\n"
"    #if defined(USE_PRIMARY_LIGHT)\n"
"\tvec3 H2 = normalize(L2 + E);\n"
"\tfloat EH2 = clamp(dot(E, H2), 0.0, 1.0);\n"
"\tfloat NH2 = clamp(dot(N, H2), 0.0, 1.0);\n"
"\n"
"\n"
"      #if defined(USE_SHADOWMAP)\n"
"\tgl_FragColor.rgb += u_PrimaryLightColor * shadowValue * NL2 * CalcSpecular(specularReflectance.rgb, NH2, NL2, NE, EH2, shininess);\n"
"      #else\n"
"\tgl_FragColor.rgb += u_PrimaryLightColor * NL2 * CalcSpecular(specularReflectance.rgb, NH2, NL2, NE, EH2, shininess);\n"
"      #endif\n"
"    #endif\n"
"  #endif  \n"
"#else\n"
"\tgl_FragColor.rgb = diffuseAlbedo.rgb;\n"
"#endif\n"
"\n"
"\tgl_FragColor.a = diffuseAlbedo.a;\n"
"\n"
"\tgl_FragColor *= var_Color;\n"
"}\n"
;
const char *fallbackShader_lightall_vp =
"attribute vec4 attr_TexCoord0;\n"
"#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)\n"
"attribute vec4 attr_TexCoord1;\n"
"#endif\n"
"attribute vec4 attr_Color;\n"
"\n"
"attribute vec4 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"\n"
"#if defined(USE_VERT_TANGENT_SPACE)\n"
"attribute vec3 attr_Tangent;\n"
"attribute vec3 attr_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec4 attr_Position2;\n"
"attribute vec3 attr_Normal2;\n"
"  #if defined(USE_VERT_TANGENT_SPACE)\n"
"attribute vec3 attr_Tangent2;\n"
"attribute vec3 attr_Bitangent2;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_LIGHT_VECTOR)\n"
"attribute vec3 attr_LightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec3   u_ViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int    u_TCGen0;\n"
"uniform vec3   u_TCGen0Vector0;\n"
"uniform vec3   u_TCGen0Vector1;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"uniform vec4   u_DiffuseTexMatrix;\n"
"uniform vec4   u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"uniform vec4   u_BaseColor;\n"
"uniform vec4   u_VertColor;\n"
"\n"
"#if defined(USE_MODELMATRIX)\n"
"uniform mat4   u_ModelMatrix;\n"
"#endif\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float  u_VertexLerp;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"uniform vec4   u_LightOrigin;\n"
"  #if defined(USE_FAST_LIGHT)\n"
"uniform vec3   u_DirectedLight;\n"
"uniform vec3   u_AmbientLight;\n"
"uniform float  u_LightRadius;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec4  u_PrimaryLightOrigin;\n"
"#endif\n"
"\n"
"varying vec2   var_DiffuseTex;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"varying vec2   var_LightTex;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"varying vec3   var_SampleToView;\n"
"#endif\n"
"\n"
"varying vec4   var_Color;\n"
"\n"
"#if defined(USE_NORMALMAP) && !defined(USE_VERT_TANGENT_SPACE)\n"
"varying vec3   var_Position;\n"
"#endif\n"
"\n"
"\n"
"#if !defined(USE_FAST_LIGHT)\n"
"varying vec3   var_Normal;\n"
"  #if defined(USE_VERT_TANGENT_SPACE)\n"
"varying vec3   var_Tangent;\n"
"varying vec3   var_Bitangent;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)\n"
"varying vec3   var_VertLight;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)\n"
"varying vec3   var_LightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"varying vec3   var_PrimaryLightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"\tvec2 tex = attr_TexCoord0.st;\n"
"\n"
"\tif (TCGen == TCGEN_LIGHTMAP)\n"
"\t{\n"
"\t\ttex = attr_TexCoord1.st;\n"
"\t}\n"
"\telse if (TCGen == TCGEN_ENVIRONMENT_MAPPED)\n"
"\t{\n"
"\t\tvec3 viewer = normalize(u_ViewOrigin - position);\n"
"\t\ttex = -reflect(viewer, normal).yz * vec2(0.5, -0.5) + 0.5;\n"
"\t}\n"
"\telse if (TCGen == TCGEN_VECTOR)\n"
"\t{\n"
"\t\ttex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"\t}\n"
"\t\n"
"\treturn tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"\tfloat amplitude = offTurb.z;\n"
"\tfloat phase = offTurb.w;\n"
"\tvec2 st2 = vec2(dot(st, texMatrix.xz), dot(st, texMatrix.yw)) + offTurb.xy;\n"
"\n"
"\tvec3 offsetPos = vec3(0); //position / 1024.0;\n"
"\toffsetPos.x += offsetPos.z;\n"
"\t\n"
"\tvec2 texOffset = sin((offsetPos.xy + vec2(phase)) * 2.0 * M_PI);\n"
"\t\n"
"\treturn st2 + texOffset * amplitude;\t\n"
"}\n"
"#endif\n"
"\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"\tvec4 position  = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"\tvec3 normal    = normalize(mix(attr_Normal,    attr_Normal2,    u_VertexLerp));\n"
"  #if defined(USE_VERT_TANGENT_SPACE)\n"
"\tvec3 tangent   = normalize(mix(attr_Tangent,   attr_Tangent2,   u_VertexLerp));\n"
"\tvec3 bitangent = normalize(mix(attr_Bitangent, attr_Bitangent2, u_VertexLerp));\n"
"  #endif\n"
"#else\n"
"\tvec4 position  = attr_Position;\n"
"\tvec3 normal    = attr_Normal;\n"
"  #if defined(USE_VERT_TANGENT_SPACE)\n"
"\tvec3 tangent   = attr_Tangent;\n"
"\tvec3 bitangent = attr_Bitangent;\n"
"  #endif\n"
"#endif\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\n"
"#if (defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)\n"
"\tvec3 L = attr_LightDirection;\n"
"#endif\n"
"\t\n"
"#if defined(USE_MODELMATRIX)\n"
"\tposition  = u_ModelMatrix * position;\n"
"\tnormal    = (u_ModelMatrix * vec4(normal, 0.0)).xyz;\n"
"  #if defined(USE_VERT_TANGENT_SPACE)\n"
"\ttangent   = (u_ModelMatrix * vec4(tangent, 0.0)).xyz;\n"
"\tbitangent = (u_ModelMatrix * vec4(bitangent, 0.0)).xyz;\n"
"  #endif\n"
"\n"
"  #if defined(USE_LIGHTMAP) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)\n"
"\tL = (u_ModelMatrix * vec4(L, 0.0)).xyz;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP) && !defined(USE_VERT_TANGENT_SPACE)\n"
"\tvar_Position = position.xyz;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT))\n"
"\tvar_SampleToView = u_ViewOrigin - position.xyz;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"\tvec2 texCoords = GenTexCoords(u_TCGen0, position.xyz, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"\tvec2 texCoords = attr_TexCoord0.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"\tvar_DiffuseTex = ModTexCoords(texCoords, position.xyz, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"\tvar_DiffuseTex = texCoords;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"\tvar_LightTex = attr_TexCoord1.st;\n"
"#endif\n"
"\n"
"#if !defined(USE_FAST_LIGHT)\n"
"\tvar_Normal = normal;\n"
"  #if defined(USE_VERT_TANGENT_SPACE)\n"
"\tvar_Tangent = tangent;\n"
"\tvar_Bitangent = bitangent;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_DELUXEMAP)\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"\tvec3 L = u_LightOrigin.xyz - (position.xyz * u_LightOrigin.w);\n"
"  #endif\n"
"  #if !defined(USE_FAST_LIGHT)\n"
"\tvar_LightDirection = L;\n"
"  #endif\n"
"#endif\n"
"\t\n"
"#if defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)\n"
"\tvar_VertLight = u_VertColor.rgb * attr_Color.rgb;\n"
"\tvar_Color.rgb = vec3(1.0);\n"
"\tvar_Color.a = u_VertColor.a * attr_Color.a + u_BaseColor.a;\n"
"#else\n"
"\tvar_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR) && defined(USE_FAST_LIGHT)\n"
"  #if defined(USE_INVSQRLIGHT)\n"
"\tfloat intensity = 1.0 / dot(L, L);\n"
"  #else\n"
"\tfloat intensity = clamp((1.0 - dot(L, L) / (u_LightRadius * u_LightRadius)) * 1.07, 0.0, 1.0);\n"
"  #endif\n"
"\tfloat NL = clamp(dot(normal, normalize(L)), 0.0, 1.0);\n"
"\n"
"\tvar_Color.rgb *= u_DirectedLight * intensity * NL + u_AmbientLight;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"\tvar_PrimaryLightDirection = u_PrimaryLightOrigin.xyz - (position.xyz * u_PrimaryLightOrigin.w);\n"
"#endif\t\n"
"}\n"
;
const char *fallbackShader_pshadow_fp =
"uniform sampler2D u_ShadowMap;\n"
"\n"
"uniform vec3      u_LightForward;\n"
"uniform vec3      u_LightUp;\n"
"uniform vec3      u_LightRight;\n"
"uniform vec4      u_LightOrigin;\n"
"uniform float     u_LightRadius;\n"
"varying vec3      var_Position;\n"
"varying vec3      var_Normal;\n"
"\n"
"float sampleDistMap(sampler2D texMap, vec2 uv, float scale)\n"
"{\n"
"\tvec3 distv = texture2D(texMap, uv).xyz;\n"
"\treturn dot(distv, vec3(1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0)) * scale;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tvec3 lightToPos = var_Position - u_LightOrigin.xyz;\n"
"\tvec2 st = vec2(-dot(u_LightRight, lightToPos), dot(u_LightUp, lightToPos));\n"
"\t\n"
"\tfloat fade = length(st);\n"
"\t\n"
"#if defined(USE_DISCARD)\n"
"\tif (fade >= 1.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"#endif\n"
"\n"
"\tfade = clamp(8.0 - fade * 8.0, 0.0, 1.0);\n"
"\t\n"
"\tst = st * 0.5 + vec2(0.5);\n"
"\n"
"#if defined(USE_SOLID_PSHADOWS)\n"
"\tfloat intensity = max(sign(u_LightRadius - length(lightToPos)), 0.0);\n"
"#else\n"
"\tfloat intensity = clamp((1.0 - dot(lightToPos, lightToPos) / (u_LightRadius * u_LightRadius)) * 2.0, 0.0, 1.0);\n"
"#endif\n"
"\t\n"
"\tfloat lightDist = length(lightToPos);\n"
"\tfloat dist;\n"
"\n"
"#if defined(USE_DISCARD)\n"
"\tif (dot(u_LightForward, lightToPos) <= 0.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"\n"
"\tif (dot(var_Normal, lightToPos) > 0.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"#else\n"
"\tintensity *= max(sign(dot(u_LightForward, lightToPos)), 0.0);\n"
"\tintensity *= max(sign(-dot(var_Normal, lightToPos)), 0.0);\n"
"#endif\n"
"\n"
"\tintensity *= fade;\n"
"#if defined(USE_PCF)\n"
"\tfloat part;\n"
"\t\n"
"\tdist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/512.0, -1.0/512.0), u_LightRadius);\n"
"\tpart =  max(sign(lightDist - dist), 0.0);\n"
"\n"
"\tdist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0, -1.0/512.0), u_LightRadius);\n"
"\tpart += max(sign(lightDist - dist), 0.0);\n"
"\n"
"\tdist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/512.0,  1.0/512.0), u_LightRadius);\n"
"\tpart += max(sign(lightDist - dist), 0.0);\n"
"\n"
"\tdist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0,  1.0/512.0), u_LightRadius);\n"
"\tpart += max(sign(lightDist - dist), 0.0);\n"
"\n"
"  #if defined(USE_DISCARD)\n"
"\tif (part <= 0.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"  #endif\n"
"\n"
"\tintensity *= part * 0.25;\n"
"#else\n"
"\tdist = sampleDistMap(u_ShadowMap, st, u_LightRadius);\n"
"\n"
"  #if defined(USE_DISCARD)\n"
"\tif (lightDist - dist <= 0.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"  #endif\n"
"\t\t\t\n"
"\tintensity *= max(sign(lightDist - dist), 0.0);\n"
"#endif\n"
"\t\t\n"
"\tgl_FragColor.rgb = vec3(0);\n"
"\tgl_FragColor.a = clamp(intensity, 0.0, 0.75);\n"
"}\n"
;
const char *fallbackShader_pshadow_vp =
"attribute vec4 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"varying vec3   var_Position;\n"
"varying vec3   var_Normal;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 position  = attr_Position;\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\n"
"\tvar_Position  = position.xyz;\n"
"\tvar_Normal    = attr_Normal;\n"
"}\n"
;
const char *fallbackShader_shadowfill_fp =
"uniform vec4  u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"\n"
"varying vec3  var_Position;\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_DEPTH)\n"
"\tfloat depth = length(u_LightOrigin.xyz - var_Position) / u_LightRadius;\n"
" #if 0\n"
"\t// 32 bit precision\n"
"\tconst vec4 bitSh = vec4( 256 * 256 * 256,   256 * 256,         256,           1);\n"
"\tconst vec4 bitMsk = vec4(              0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n"
"\t\n"
"\tvec4 comp;\n"
"\tcomp = depth * bitSh;\n"
"\tcomp.xyz = fract(comp.xyz);\n"
"\tcomp -= comp.xxyz * bitMsk;\n"
"\tgl_FragColor = comp;\n"
" #endif\n"
"\n"
" #if 1\n"
"\t// 24 bit precision\n"
"\tconst vec3 bitSh = vec3( 256 * 256,         256,           1);\n"
"\tconst vec3 bitMsk = vec3(        0, 1.0 / 256.0, 1.0 / 256.0);\n"
"\t\n"
"\tvec3 comp;\n"
"\tcomp = depth * bitSh;\n"
"\tcomp.xy = fract(comp.xy);\n"
"\tcomp -= comp.xxy * bitMsk;\n"
"\tgl_FragColor = vec4(comp, 1.0);\n"
" #endif\n"
"\n"
" #if 0\n"
"\t// 8 bit precision\n"
"\tgl_FragColor = vec4(depth, depth, depth, 1);\n"
" #endif\n"
"#else\n"
"\tgl_FragColor = vec4(0, 0, 0, 1);\n"
"#endif\n"
"}\n"
;
const char *fallbackShader_shadowfill_vp =
"attribute vec4  attr_Position;\n"
"attribute vec3  attr_Normal;\n"
"attribute vec4  attr_TexCoord0;\n"
"\n"
"//#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec4  attr_Position2;\n"
"attribute vec3  attr_Normal2;\n"
"//#endif\n"
"\n"
"//#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int     u_DeformGen;\n"
"uniform float    u_DeformParams[5];\n"
"//#endif\n"
"\n"
"uniform float   u_Time;\n"
"uniform mat4    u_ModelViewProjectionMatrix;\n"
"\n"
"uniform mat4   u_ModelMatrix;\n"
"\n"
"//#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float   u_VertexLerp;\n"
"//#endif\n"
"\n"
"varying vec3    var_Position;\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"\tif (u_DeformGen == 0)\n"
"\t{\n"
"\t\treturn pos;\n"
"\t}\n"
"\n"
"\tfloat base =      u_DeformParams[0];\n"
"\tfloat amplitude = u_DeformParams[1];\n"
"\tfloat phase =     u_DeformParams[2];\n"
"\tfloat frequency = u_DeformParams[3];\n"
"\tfloat spread =    u_DeformParams[4];\n"
"\n"
"\tif (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tphase *= M_PI * 0.25 * st.x;\n"
"\t}\n"
"\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tphase += dot(pos.xyz, vec3(spread));\n"
"\t}\n"
"\n"
"\tfloat value = phase + (u_Time * frequency);\n"
"\tfloat func;\n"
"\n"
"\tif (u_DeformGen == DGEN_WAVE_SIN)\n"
"\t{\n"
"\t\tfunc = sin(value * 2.0 * M_PI);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SQUARE)\n"
"\t{\n"
"\t\tfunc = sign(sin(value * 2.0 * M_PI));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\n"
"\t{\n"
"\t\tfunc = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = fract(value);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = (1.0 - fract(value));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tfunc = sin(value);\n"
"\t}\n"
"\n"
"\treturn pos + normal * (base + func * amplitude);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 position = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"\tvec3 normal = normalize(mix(attr_Normal, attr_Normal2, u_VertexLerp));\n"
"\n"
"\tposition.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\t\n"
"\tvar_Position  = (u_ModelMatrix * position).xyz;\n"
"}\n"
;
const char *fallbackShader_shadowmask_fp =
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform sampler2D u_ShadowMap;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform sampler2D u_ShadowMap2;\n"
"uniform sampler2D u_ShadowMap3;\n"
"#endif\n"
"\n"
"uniform mat4      u_ShadowMvp;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform mat4      u_ShadowMvp2;\n"
"uniform mat4      u_ShadowMvp3;\n"
"#endif\n"
"\n"
"uniform vec3   u_ViewOrigin;\n"
"uniform vec4   u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"varying vec2   var_DepthTex;\n"
"varying vec3   var_ViewDir;\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  \n"
"}\n"
"\n"
"float PCF(const sampler2D shadowmap, const vec2 st, const float dist)\n"
"{\n"
"\tfloat mult;\n"
"\tfloat scale = 2.0 / r_shadowMapSize;\n"
"\t\t\n"
"#if defined(USE_SHADOW_FILTER)\n"
"\tfloat r = random(var_DepthTex.xy);\n"
"\tfloat sinr = sin(r) * scale;\n"
"\tfloat cosr = cos(r) * scale;\n"
"\tmat2 rmat = mat2(cosr, sinr, -sinr, cosr);\n"
"\n"
"\tmult =  step(dist, texture2D(shadowmap, st + rmat * vec2(-0.7055767, 0.196515)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.3524343, -0.7791386)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.2391056, 0.9189604)).r);\n"
"  #if defined(USE_SHADOW_FILTER2)\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(-0.07580382, -0.09224417)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.5784913, -0.002528916)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.192888, 0.4064181)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(-0.6335801, -0.5247476)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(-0.5579782, 0.7491854)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.7320465, 0.6317794)).r);\n"
"\n"
"\tmult *= 0.11111;\n"
"  #else\n"
"    mult *= 0.33333;\n"
"  #endif\n"
"#else\n"
"\tmult = step(dist, texture2D(shadowmap, st).r);\n"
"#endif\n"
"\t\t\n"
"\treturn mult;\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, vec2 tex, float zFarDivZNear)\n"
"{\n"
"\t\tfloat sampleZDivW = texture2D(depthMap, tex).r;\n"
"\t\treturn 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tfloat result;\n"
"\t\n"
"\tfloat depth = getLinearDepth(u_ScreenDepthMap, var_DepthTex, u_ViewInfo.x);\n"
"\tfloat sampleZ = u_ViewInfo.y * depth;\n"
"\n"
"\tvec4 biasPos = vec4(u_ViewOrigin + var_ViewDir * depth * 0.99, 1.0);\n"
"\t\n"
"\tvec4 shadowpos = u_ShadowMvp * biasPos;\n"
"\t\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"\tconst float fadeTo = 1.0;\n"
"\tresult = fadeTo;\n"
"#else\n"
"\tresult = 0.0;\n"
"#endif\n"
"\n"
"\tif (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"\t{\n"
"\t\tshadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\n"
"\t\tresult = PCF(u_ShadowMap, shadowpos.xy, shadowpos.z);\n"
"\t}\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"\telse\n"
"\t{\n"
"\t\tshadowpos = u_ShadowMvp2 * biasPos;\n"
"\n"
"\t\tif (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"\t\t{\n"
"\t\t\tshadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\n"
"\t\t\tresult = PCF(u_ShadowMap2, shadowpos.xy, shadowpos.z);\n"
"\t\t}\n"
"\t\telse\n"
"\t\t{\n"
"\t\t\tshadowpos = u_ShadowMvp3 * biasPos;\n"
"\n"
"\t\t\tif (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"\t\t\t{\n"
"\t\t\t\tshadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\n"
"\t\t\t\tresult = PCF(u_ShadowMap3, shadowpos.xy, shadowpos.z);\n"
"\n"
"\t\t\t\tfloat fade = clamp(sampleZ / r_shadowCascadeZFar * 10.0 - 9.0, 0.0, 1.0);\n"
"\t\t\t\tresult = mix(result, fadeTo, fade);\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"#endif\n"
"\t\t\n"
"\tgl_FragColor = vec4(vec3(result), 1.0);\n"
"}\n"
;
const char *fallbackShader_shadowmask_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform vec3   u_ViewForward;\n"
"uniform vec3   u_ViewLeft;\n"
"uniform vec3   u_ViewUp;\n"
"uniform vec4   u_ViewInfo; // zfar / znear\n"
"\n"
"varying vec2   var_DepthTex;\n"
"varying vec3   var_ViewDir;\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = attr_Position;\n"
"\tvec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"\tvar_DepthTex = attr_TexCoord0.xy;\n"
"\tvar_ViewDir = u_ViewForward + u_ViewLeft * -screenCoords.x + u_ViewUp * screenCoords.y;\n"
"}\n"
;
const char *fallbackShader_ssao_fp =
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform vec4   u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"varying vec2   var_ScreenTex;\n"
"\n"
"vec2 poissonDisc[9] = vec2[9](\n"
"vec2(-0.7055767, 0.196515),    vec2(0.3524343, -0.7791386),\n"
"vec2(0.2391056, 0.9189604),    vec2(-0.07580382, -0.09224417),\n"
"vec2(0.5784913, -0.002528916), vec2(0.192888, 0.4064181),\n"
"vec2(-0.6335801, -0.5247476),  vec2(-0.5579782, 0.7491854),\n"
"vec2(0.7320465, 0.6317794)\n"
");\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  \n"
"}\n"
"\n"
"mat2 randomRotation( const vec2 p )\n"
"{\n"
"\tfloat r = random(p);\n"
"\tfloat sinr = sin(r);\n"
"\tfloat cosr = cos(r);\n"
"\treturn mat2(cosr, sinr, -sinr, cosr);\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"\t\tfloat sampleZDivW = texture2D(depthMap, tex).r;\n"
"\t\treturn 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"float ambientOcclusion(sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const float zFar)\n"
"{\n"
"\tfloat result = 0;\n"
"\n"
"\tfloat sampleZ = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"\n"
"\tvec2 expectedSlope = vec2(dFdx(sampleZ), dFdy(sampleZ)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"\t\n"
"\tif (length(expectedSlope) > 5000.0)\n"
"\t\treturn 1.0;\n"
"\t\n"
"\tvec2 offsetScale = vec2(3.0 / sampleZ);\n"
"\t\n"
"\tmat2 rmat = randomRotation(tex);\n"
"\t\t\n"
"\tint i;\n"
"\tfor (i = 0; i < 3; i++)\n"
"\t{\n"
"\t\tvec2 offset = rmat * poissonDisc[i] * offsetScale;\n"
"\t\tfloat sampleZ2 = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"\n"
"\t\tif (abs(sampleZ - sampleZ2) > 20.0)\n"
"\t\t\tresult += 1.0;\n"
"\t\telse\n"
"\t\t{\n"
"\t\t\tfloat expectedZ = sampleZ + dot(expectedSlope, offset);\n"
"\t\t\tresult += step(expectedZ - 1.0, sampleZ2);\n"
"\t\t}\n"
"\t}\n"
"\t\n"
"\tresult *= 0.33333;\n"
"\t\n"
"\treturn result;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tfloat result = ambientOcclusion(u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);\n"
"\t\t\t\n"
"\tgl_FragColor = vec4(vec3(result), 1.0);\n"
"}\n"
;
const char *fallbackShader_ssao_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"varying vec2   var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = attr_Position;\n"
"\tvar_ScreenTex = attr_TexCoord0.xy;\n"
"\t//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"\t//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;
const char *fallbackShader_texturecolor_fp =
"#version 120\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform vec4      u_Color;\n"
"\n"
"varying vec2         var_Tex1;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_FragColor = texture2D(u_DiffuseMap, var_Tex1) * u_Color;\n"
"}\n"
;
const char *fallbackShader_texturecolor_vp =
"#version 120\n"
"\n"
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_Tex1;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_Tex1 = attr_TexCoord0.st;\n"
"}\n"
;
const char *fallbackShader_tonemap_fp =
"uniform sampler2D u_TextureMap;\n"
"uniform sampler2D u_LevelsMap;\n"
"\n"
"uniform vec4      u_Color;\n"
"\n"
"uniform vec2      u_AutoExposureMinMax;\n"
"uniform vec3      u_ToneMinAvgMaxLinear;\n"
"\n"
"varying vec2      var_TexCoords;\n"
"\n"
"const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 FilmicTonemap(vec3 x)\n"
"{\n"
"\tconst float SS  = 0.22; // Shoulder Strength\n"
"\tconst float LS  = 0.30; // Linear Strength\n"
"\tconst float LA  = 0.10; // Linear Angle\n"
"\tconst float TS  = 0.20; // Toe Strength\n"
"\tconst float TAN = 0.01; // Toe Angle Numerator\n"
"\tconst float TAD = 0.30; // Toe Angle Denominator\n"
"\t\n"
"\tvec3 SSxx = SS * x * x;\n"
"\tvec3 LSx = LS * x;\n"
"\tvec3 LALSx = LSx * LA;\n"
"\t\n"
"\treturn ((SSxx + LALSx + TS * TAN) / (SSxx + LSx + TS * TAD)) - TAN / TAD;\n"
"\n"
"\t//return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color = texture2D(u_TextureMap, var_TexCoords) * u_Color;\n"
"\tvec3 minAvgMax = texture2D(u_LevelsMap, var_TexCoords).rgb;\n"
"\tvec3 logMinAvgMaxLum = clamp(minAvgMax * 20.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x);\n"
"\t\t\n"
"\tfloat avgLum = exp2(logMinAvgMaxLum.y);\n"
"\t//float maxLum = exp2(logMinAvgMaxLum.z);\n"
"\n"
"\tcolor.rgb *= u_ToneMinAvgMaxLinear.y / avgLum;\n"
"\tcolor.rgb = max(vec3(0.0), color.rgb - vec3(u_ToneMinAvgMaxLinear.x));\n"
"\n"
"\tvec3 fWhite = 1.0 / FilmicTonemap(vec3(u_ToneMinAvgMaxLinear.z - u_ToneMinAvgMaxLinear.x));\n"
"\tcolor.rgb = FilmicTonemap(color.rgb) * fWhite;\n"
"\t\n"
"\tgl_FragColor = clamp(color, 0.0, 1.0);\n"
"}\n"
;
const char *fallbackShader_tonemap_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_TexCoords = attr_TexCoord0.st;\n"
"}\n"
;
