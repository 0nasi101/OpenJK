#include "tr_local.h"

const char *fallbackShader_bokeh_fp =
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4      u_Color;\n"
"\n"
"uniform vec2      u_InvTexRes;\n"
"varying vec2      var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color;\n"
"\tvec2 tc;\n"
"\n"
"#if 0\n"
"\tfloat c[7] = float[7](1.0, 0.9659258263, 0.8660254038, 0.7071067812, 0.5, 0.2588190451, 0.0);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[6]);  color =  texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[6],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[6], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[6]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[5]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[4],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[5],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[5]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[4], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[5], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\t\n"
"\tgl_FragColor = color * 0.04166667 * u_Color;\n"
"#endif\n"
"\n"
"\tfloat c[5] = float[5](1.0, 0.9238795325, 0.7071067812, 0.3826834324, 0.0);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[4]);  color =  texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[0]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[4]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[3]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[2]);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[1]);  color += texture2D(u_TextureMap, tc);\n"
"\t\n"
"\tgl_FragColor = color * 0.0625 * u_Color;\n"
"}\n"
;
const char *fallbackShader_bokeh_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_TexCoords = attr_TexCoord0.st;\n"
"}\n"
;
const char *fallbackShader_calclevels4x_fp =
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec4      u_Color;\n"
"\n"
"uniform vec2      u_InvTexRes;\n"
"varying vec2      var_TexCoords;\n"
"\n"
"const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 GetValues(vec2 offset, vec3 current)\n"
"{\n"
"\tvec3 minAvgMax;\n"
"\tvec2 tc = var_TexCoords + u_InvTexRes * offset; minAvgMax = texture2D(u_TextureMap, tc).rgb;\n"
"\n"
"#ifdef FIRST_PASS\n"
"\tfloat lumi = max(dot(LUMINANCE_VECTOR, minAvgMax), 0.000001);\n"
"\tfloat loglumi = clamp(log2(lumi), -10.0, 10.0);\n"
"\tminAvgMax = vec3(loglumi * 0.05 + 0.5);\n"
"#endif\n"
"\n"
"\treturn vec3(min(current.x, minAvgMax.x), current.y + minAvgMax.y, max(current.z, minAvgMax.z));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tvec3 current = vec3(1.0, 0.0, 0.0);\n"
"\n"
"#ifdef FIRST_PASS\n"
"\tcurrent = GetValues(vec2( 0.0,  0.0), current);\n"
"#else\n"
"\tcurrent = GetValues(vec2(-1.5, -1.5), current);\n"
"\tcurrent = GetValues(vec2(-0.5, -1.5), current);\n"
"\tcurrent = GetValues(vec2( 0.5, -1.5), current);\n"
"\tcurrent = GetValues(vec2( 1.5, -1.5), current);\n"
"\t\n"
"\tcurrent = GetValues(vec2(-1.5, -0.5), current);\n"
"\tcurrent = GetValues(vec2(-0.5, -0.5), current);\n"
"\tcurrent = GetValues(vec2( 0.5, -0.5), current);\n"
"\tcurrent = GetValues(vec2( 1.5, -0.5), current);\n"
"\t\n"
"\tcurrent = GetValues(vec2(-1.5,  0.5), current);\n"
"\tcurrent = GetValues(vec2(-0.5,  0.5), current);\n"
"\tcurrent = GetValues(vec2( 0.5,  0.5), current);\n"
"\tcurrent = GetValues(vec2( 1.5,  0.5), current);\n"
"\n"
"\tcurrent = GetValues(vec2(-1.5,  1.5), current);\n"
"\tcurrent = GetValues(vec2(-0.5,  1.5), current);\n"
"\tcurrent = GetValues(vec2( 0.5,  1.5), current);\n"
"\tcurrent = GetValues(vec2( 1.5,  1.5), current);\n"
"\n"
"\tcurrent.y *= 0.0625;\n"
"#endif\n"
"\n"
"\tgl_FragColor = vec4(current, 1.0f);\n"
"}\n"
;
const char *fallbackShader_calclevels4x_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_TexCoords = attr_TexCoord0.st;\n"
"}\n"
;
const char *fallbackShader_depthblur_fp =
"uniform sampler2D u_ScreenImageMap;\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform vec4   u_ViewInfo; // zfar / znear, zfar\n"
"varying vec2   var_ScreenTex;\n"
"\n"
"//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024, 0.0033);\n"
"float gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);\n"
"//float gauss[3] = float[3](0.60, 0.19, 0.0066);\n"
"#define GAUSS_SIZE 4\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"\t\tfloat sampleZDivW = texture2D(depthMap, tex).r;\n"
"\t\treturn 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"vec4 depthGaussian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar)\n"
"{\n"
"\tfloat scale = 1.0 / 256.0;\n"
"\n"
"#if defined(USE_HORIZONTAL_BLUR)\n"
"    vec2 direction = vec2(1.0, 0.0) * scale;\n"
"#else // if defined(USE_VERTICAL_BLUR)\n"
"\tvec2 direction = vec2(0.0, 1.0) * scale;\n"
"#endif\n"
"\t\n"
"\tfloat depthCenter = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"\tvec2 centerSlope = vec2(dFdx(depthCenter), dFdy(depthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"\t\t\n"
"\tvec4 result = texture2D(imageMap, tex) * gauss[0];\n"
"\tfloat total = gauss[0];\n"
"\n"
"\tint i, j;\n"
"\tfor (i = 0; i < 2; i++)\n"
"\t{\n"
"\t\tfor (j = 1; j < GAUSS_SIZE; j++)\n"
"\t\t{\n"
"\t\t\tvec2 offset = direction * j;\n"
"\t\t\tfloat depthSample = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"\t\t\tfloat depthExpected = depthCenter + dot(centerSlope, offset);\n"
"\t\t\tif(abs(depthSample - depthExpected) < 5.0)\n"
"\t\t\t{\n"
"\t\t\t\tresult += texture2D(imageMap, tex + offset) * gauss[j];\n"
"\t\t\t\ttotal += gauss[j];\n"
"\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\tdirection = -direction;\n"
"\t}\t\n"
"\t\t\n"
"\treturn result / total;\n"
"}\n"
"\n"
"void main()\n"
"{\t\t\n"
"\tgl_FragColor = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);\n"
"}\n"
;
const char *fallbackShader_depthblur_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"varying vec2   var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = attr_Position;\n"
"\tvar_ScreenTex = attr_TexCoord0.xy;\n"
"\t//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"\t//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;
const char *fallbackShader_dlight_fp =
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"varying vec2      var_Tex1;\n"
"varying vec4      var_Color;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color = texture2D(u_DiffuseMap, var_Tex1);\n"
"\n"
"\tgl_FragColor = color * var_Color;\n"
"}\n"
;
const char *fallbackShader_dlight_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"attribute vec3 attr_Normal;\n"
"\n"
"uniform vec4   u_DlightInfo;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int    u_DeformGen;\n"
"uniform float  u_DeformParams[5];\n"
"uniform float  u_Time;\n"
"#endif\n"
"\n"
"uniform vec4   u_Color;\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_Tex1;\n"
"varying vec4   var_Color;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"\tif (u_DeformGen == 0)\n"
"\t{\n"
"\t\treturn pos;\n"
"\t}\n"
"\n"
"\tfloat base =      u_DeformParams[0];\n"
"\tfloat amplitude = u_DeformParams[1];\n"
"\tfloat phase =     u_DeformParams[2];\n"
"\tfloat frequency = u_DeformParams[3];\n"
"\tfloat spread =    u_DeformParams[4];\n"
"\n"
"\tif (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tphase *= M_PI * 0.25 * st.x;\n"
"\t}\n"
"\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tphase += dot(pos.xyz, vec3(spread));\n"
"\t}\n"
"\n"
"\tfloat value = phase + (u_Time * frequency);\n"
"\tfloat func;\n"
"\n"
"\tif (u_DeformGen == DGEN_WAVE_SIN)\n"
"\t{\n"
"\t\tfunc = sin(value * 2.0 * M_PI);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SQUARE)\n"
"\t{\n"
"\t\tfunc = sign(sin(value * 2.0 * M_PI));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\n"
"\t{\n"
"\t\tfunc = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = fract(value);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = (1.0 - fract(value));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tfunc = sin(value);\n"
"\t}\n"
"\n"
"\treturn pos + normal * (base + func * amplitude);\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 position = attr_Position;\n"
"\tvec3 normal = attr_Normal;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"\tposition.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);\n"
"#endif\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\t\t\n"
"\tvec3 dist = u_DlightInfo.xyz - position.xyz;\t\n"
"\n"
"\tvar_Tex1 = dist.xy * u_DlightInfo.a + vec2(0.5);\n"
"\tfloat dlightmod = step(0.0, dot(dist, normal));\n"
"\tdlightmod *= clamp(2.0 * (1.0 - abs(dist.z) * u_DlightInfo.a), 0.0, 1.0);\n"
"\t\n"
"\tvar_Color = u_Color * dlightmod;\n"
"}\n"
;
const char *fallbackShader_down4x_fp =
"uniform sampler2D u_TextureMap;\n"
"\n"
"uniform vec2      u_InvTexRes;\n"
"varying vec2      var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color;\n"
"\tvec2 tc;\n"
"\t\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-1.5, -1.5);  color  = texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5, -1.5);  color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5, -0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5,  0.5); color += texture2D(u_TextureMap, tc);\n"
"\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2(-0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 0.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\ttc = var_TexCoords + u_InvTexRes * vec2( 1.5,  1.5);  color += texture2D(u_TextureMap, tc);\n"
"\t\n"
"\tcolor *= 0.0625;\n"
"\t\n"
"\tgl_FragColor = color;\n"
"}\n"
;
const char *fallbackShader_down4x_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_TexCoords = attr_TexCoord0.st;\n"
"}\n"
;
const char *fallbackShader_fogpass_fp =
"uniform vec4  u_Color;\n"
"\n"
"varying float var_Scale;\n"
"\n"
"void main()\n"
"{\n"
"\tgl_FragColor = u_Color;\n"
"\tgl_FragColor.a *= sqrt(clamp(var_Scale, 0.0, 1.0));\n"
"}\n"
;
const char *fallbackShader_fogpass_vp =
"attribute vec4  attr_Position;\n"
"attribute vec3  attr_Normal;\n"
"attribute vec4  attr_TexCoord0;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec4  attr_Position2;\n"
"attribute vec3  attr_Normal2;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"attribute vec4 attr_BoneIndexes;\n"
"attribute vec4 attr_BoneWeights;\n"
"#endif\n"
"\n"
"uniform vec4    u_FogDistance;\n"
"uniform vec4    u_FogDepth;\n"
"uniform float   u_FogEyeT;\n"
"\n"
"//#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int     u_DeformGen;\n"
"uniform float   u_DeformParams[5];\n"
"//#endif\n"
"\n"
"uniform float   u_Time;\n"
"uniform mat4    u_ModelViewProjectionMatrix;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float   u_VertexLerp;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"uniform mat4    u_BoneMatrices[80];\n"
"#endif\n"
"\n"
"varying float   var_Scale;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"\tif (u_DeformGen == 0)\n"
"\t{\n"
"\t\treturn pos;\n"
"\t}\n"
"\n"
"\tfloat base =      u_DeformParams[0];\n"
"\tfloat amplitude = u_DeformParams[1];\n"
"\tfloat phase =     u_DeformParams[2];\n"
"\tfloat frequency = u_DeformParams[3];\n"
"\tfloat spread =    u_DeformParams[4];\n"
"\n"
"\tif (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tphase *= M_PI * 0.25 * st.x;\n"
"\t}\n"
"\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tphase += dot(pos.xyz, vec3(spread));\n"
"\t}\n"
"\n"
"\tfloat value = phase + (u_Time * frequency);\n"
"\tfloat func;\n"
"\n"
"\tif (u_DeformGen == DGEN_WAVE_SIN)\n"
"\t{\n"
"\t\tfunc = sin(value * 2.0 * M_PI);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SQUARE)\n"
"\t{\n"
"\t\tfunc = sign(sin(value * 2.0 * M_PI));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\n"
"\t{\n"
"\t\tfunc = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = fract(value);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = (1.0 - fract(value));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tfunc = sin(value);\n"
"\t}\n"
"\n"
"\treturn pos + normal * (base + func * amplitude);\n"
"}\n"
"#endif\n"
"\n"
"float CalcFog(vec4 position)\n"
"{\n"
"\tfloat s = dot(position, u_FogDistance) * 8.0;\n"
"\tfloat t = dot(position, u_FogDepth);\n"
"\n"
"\tfloat eyeOutside = step(0.0, -u_FogEyeT);\n"
"\tfloat fogged = step(eyeOutside, t);\n"
"\t\t\n"
"\tt = max(t, 1e-6);\n"
"\tt *= fogged / (t - u_FogEyeT * eyeOutside);\n"
"\n"
"\treturn s * t;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"\tvec4 position = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"\tvec3 normal = normalize(mix(attr_Normal, attr_Normal2, u_VertexLerp));\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"\tvec4 position = vec4(0.0);\n"
"\tvec4 normal4 = vec4(0.0);\n"
"\tvec4 originalNormal = vec4(attr_Normal, 0.0);\n"
"\tfor (int i = 0; i < 4; i++) {\n"
"\t\tint boneIndex = int(attr_BoneIndexes[i]);\n"
"\n"
"\t\tposition += (u_BoneMatrices[boneIndex] * attr_Position) * attr_BoneWeights[i];\n"
"\t\tnormal4 += (u_BoneMatrices[boneIndex] * originalNormal) * attr_BoneWeights[i];\n"
"\t}\n"
"\tvec3 normal = normal4.xyz;\n"
"#else\n"
"\tvec4 position = attr_Position;\n"
"\tvec3 normal = attr_Normal;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"\tposition.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);\n"
"#endif\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\n"
"\tvar_Scale = CalcFog(position);\n"
"}\n"
;
const char *fallbackShader_generic_fp =
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"\n"
"uniform int       u_Texture1Env;\n"
"#endif\n"
"\n"
"varying vec2      var_DiffuseTex;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"varying vec2      var_LightTex;\n"
"#endif\n"
"\n"
"varying vec4      var_Color;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color  = texture2D(u_DiffuseMap, var_DiffuseTex);\n"
"#if defined(USE_LIGHTMAP)\n"
"\tvec4 color2 = texture2D(u_LightMap, var_LightTex);\n"
"  #if defined(RGBM_LIGHTMAP)\n"
"\tcolor2.rgb *= 32.0 * color2.a;\n"
"\tcolor2.a = 1.0;\n"
"  #endif\n"
"\n"
"\tif (u_Texture1Env == TEXENV_MODULATE)\n"
"\t{\n"
"\t\tcolor *= color2;\n"
"\t}\n"
"\telse if (u_Texture1Env == TEXENV_ADD)\n"
"\t{\n"
"\t\tcolor += color2;\n"
"\t}\n"
"\telse if (u_Texture1Env == TEXENV_REPLACE)\n"
"\t{\n"
"\t\tcolor = color2;\n"
"\t}\n"
"#endif\n"
"\n"
"\tgl_FragColor = color * var_Color;\n"
"}\n"
;
const char *fallbackShader_generic_vp =
"attribute vec4 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec4 attr_Position2;\n"
"attribute vec3 attr_Normal2;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"attribute vec4 attr_BoneIndexes;\n"
"attribute vec4 attr_BoneWeights;\n"
"#endif\n"
"\n"
"attribute vec4 attr_Color;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)\n"
"attribute vec4 attr_TexCoord1;\n"
"#endif\n"
"\n"
"uniform vec4   u_DiffuseTexMatrix;\n"
"uniform vec4   u_DiffuseTexOffTurb;\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_RGBAGEN)\n"
"uniform vec3   u_LocalViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int    u_TCGen0;\n"
"uniform vec3   u_TCGen0Vector0;\n"
"uniform vec3   u_TCGen0Vector1;\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"uniform vec4   u_FogDistance;\n"
"uniform vec4   u_FogDepth;\n"
"uniform float  u_FogEyeT;\n"
"uniform vec4   u_FogColorMask;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int    u_DeformGen;\n"
"uniform float  u_DeformParams[5];\n"
"uniform float  u_Time;\n"
"#endif\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"uniform vec4   u_BaseColor;\n"
"uniform vec4   u_VertColor;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int    u_ColorGen;\n"
"uniform int    u_AlphaGen;\n"
"uniform vec3   u_AmbientLight;\n"
"uniform vec3   u_DirectedLight;\n"
"uniform vec3   u_ModelLightDir;\n"
"uniform float  u_PortalRange;\n"
"#endif\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float  u_VertexLerp;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"uniform mat4   u_BoneMatrices[80];\n"
"#endif\n"
"\n"
"varying vec2   var_DiffuseTex;\n"
"#if defined(USE_LIGHTMAP)\n"
"varying vec2   var_LightTex;\n"
"#endif\n"
"varying vec4   var_Color;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"\tfloat base =      u_DeformParams[0];\n"
"\tfloat amplitude = u_DeformParams[1];\n"
"\tfloat phase =     u_DeformParams[2];\n"
"\tfloat frequency = u_DeformParams[3];\n"
"\tfloat spread =    u_DeformParams[4];\n"
"\n"
"\tif (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tphase *= M_PI * 0.25 * st.x;\n"
"\t}\n"
"\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tphase += dot(pos.xyz, vec3(spread));\n"
"\t}\n"
"\n"
"\tfloat value = phase + (u_Time * frequency);\n"
"\tfloat func;\n"
"\n"
"\tif (u_DeformGen == DGEN_WAVE_SIN)\n"
"\t{\n"
"\t\tfunc = sin(value * 2.0 * M_PI);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SQUARE)\n"
"\t{\n"
"\t\tfunc = sign(sin(value * 2.0 * M_PI));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\n"
"\t{\n"
"\t\tfunc = 1.0 - abs(4.0 * fract(value + 0.25) - 2.0);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = fract(value);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = (1.0 - fract(value));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tfunc = sin(value);\n"
"\t}\n"
"\n"
"\treturn pos + normal * (base + func * amplitude);\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"\tvec2 tex = attr_TexCoord0.st;\n"
"\n"
"\tif (TCGen == TCGEN_LIGHTMAP)\n"
"\t{\n"
"\t\ttex = attr_TexCoord1.st;\n"
"\t}\n"
"\telse if (TCGen == TCGEN_ENVIRONMENT_MAPPED)\n"
"\t{\n"
"\t\tvec3 viewer = normalize(u_LocalViewOrigin - position);\n"
"\t\ttex = -reflect(viewer, normal).yz * vec2(0.5, -0.5) + 0.5;\n"
"\t}\n"
"\telse if (TCGen == TCGEN_VECTOR)\n"
"\t{\n"
"\t\ttex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"\t}\n"
"\t\n"
"\treturn tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"\tfloat amplitude = offTurb.z;\n"
"\tfloat phase = offTurb.w;\n"
"\tvec2 st2 = vec2(dot(st, texMatrix.xz), dot(st, texMatrix.yw)) + offTurb.xy;\n"
"\n"
"\tvec3 offsetPos = position / 1024.0;\n"
"\toffsetPos.x += offsetPos.z;\n"
"\t\n"
"\tvec2 texOffset = sin((offsetPos.xy + vec2(phase)) * 2.0 * M_PI);\n"
"\t\n"
"\treturn st2 + texOffset * amplitude;\t\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"\tvec4 color = u_VertColor * attr_Color + u_BaseColor;\n"
"\t\n"
"\tif (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"\t{\n"
"\t\tfloat incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"\t\tcolor.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"\t}\n"
"\t\n"
"\tvec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"\tif (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"\t{\n"
"\t\tvec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position.xyz);\n"
"\t\tvec3 reflected = -reflect(lightDir, normal);\n"
"\t\t\n"
"\t\tcolor.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"\t\tcolor.a *= color.a;\n"
"\t\tcolor.a *= color.a;\n"
"\t}\n"
"\telse if (u_AlphaGen == AGEN_PORTAL)\n"
"\t{\n"
"\t\tcolor.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"\t}\n"
"\t\n"
"\treturn color;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"float CalcFog(vec4 position)\n"
"{\n"
"\tfloat s = dot(position, u_FogDistance) * 8.0;\n"
"\tfloat t = dot(position, u_FogDepth);\n"
"\n"
"\tfloat eyeOutside = step(0.0, -u_FogEyeT);\n"
"\tfloat fogged = step(eyeOutside, t);\n"
"\t\t\n"
"\tt = max(t, 1e-6);\n"
"\tt *= fogged / (t - u_FogEyeT * eyeOutside);\n"
"\n"
"\treturn s * t;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"\tvec4 position = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"\tvec3 normal = normalize(mix(attr_Normal, attr_Normal2, u_VertexLerp));\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"\tvec4 position = vec4(0.0);\n"
"\tvec4 normal4 = vec4(0.0);\n"
"\tvec4 originalNormal = vec4(attr_Normal, 0.0);\n"
"\tfor (int i = 0; i < 4; i++) {\n"
"\t\tint boneIndex = int(attr_BoneIndexes[i]);\n"
"\n"
"\t\tposition += (u_BoneMatrices[boneIndex] * attr_Position) * attr_BoneWeights[i];\n"
"\t\tnormal4 += (u_BoneMatrices[boneIndex] * originalNormal) * attr_BoneWeights[i];\n"
"\t}\n"
"\tvec3 normal = normal4.xyz;\n"
"#else\n"
"\tvec4 position = attr_Position;\n"
"\tvec3 normal = attr_Normal;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"\tposition.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);\n"
"#endif\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\n"
"#if defined(USE_TCGEN)\n"
"\tvec2 tex = GenTexCoords(u_TCGen0, position.xyz, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"\tvec2 tex = attr_TexCoord0.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"\tvar_DiffuseTex = ModTexCoords(tex, position.xyz, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"    var_DiffuseTex = tex;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"\tvar_LightTex = attr_TexCoord1.st;\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"\tvar_Color = CalcColor(position.xyz, normal);\n"
"#else\n"
"\tvar_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"\tvar_Color *= vec4(1.0) - u_FogColorMask * sqrt(clamp(CalcFog(position), 0.0, 1.0));\n"
"#endif\n"
"}\n"
;
const char *fallbackShader_lightall_fp =
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform sampler2D u_DeluxeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"#if defined(USE_CUBEMAP)\n"
"uniform samplerCube u_CubeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT)\n"
"uniform vec3      u_DirectedLight;\n"
"uniform vec3      u_AmbientLight;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec3  u_PrimaryLightColor;\n"
"uniform vec3  u_PrimaryLightAmbient;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec2      u_MaterialInfo;\n"
"#endif\n"
"\n"
"varying vec4      var_TexCoords;\n"
"\n"
"varying vec4      var_Color;\n"
"\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || defined(USE_PARALLAXMAP)\n"
"varying vec4      var_Normal;\n"
"varying vec4      var_Tangent;\n"
"varying vec4      var_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)\n"
"varying vec3      var_LightColor;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)\n"
"varying vec4      var_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"varying vec4      var_PrimaryLightDir;\n"
"#endif\n"
"\n"
"\n"
"#define EPSILON 0.00000001\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"float SampleDepth(sampler2D normalMap, vec2 t)\n"
"{\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"\treturn 1.0 - texture2D(normalMap, t).r;\n"
"  #else\n"
"\treturn 1.0 - texture2D(normalMap, t).a;\n"
"  #endif\n"
"}\n"
"\n"
"float RayIntersectDisplaceMap(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"\tconst int linearSearchSteps = 16;\n"
"\tconst int binarySearchSteps = 6;\n"
"\n"
"\t// current size of search window\n"
"\tfloat size = 1.0 / float(linearSearchSteps);\n"
"\n"
"\t// current depth position\n"
"\tfloat depth = 0.0;\n"
"\n"
"\t// best match found (starts with last position 1.0)\n"
"\tfloat bestDepth = 1.0;\n"
"\n"
"\t// search front to back for first point inside object\n"
"\tfor(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"\t{\n"
"\t\tdepth += size;\n"
"\t\t\n"
"\t\tfloat t = SampleDepth(normalMap, dp + ds * depth);\n"
"\t\t\n"
"\t\tif(bestDepth > 0.996)\t\t// if no depth found yet\n"
"\t\t\tif(depth >= t)\n"
"\t\t\t\tbestDepth = depth;\t// store best depth\n"
"\t}\n"
"\n"
"\tdepth = bestDepth;\n"
"\t\n"
"\t// recurse around first point (depth) for closest match\n"
"\tfor(int i = 0; i < binarySearchSteps; ++i)\n"
"\t{\n"
"\t\tsize *= 0.5;\n"
"\n"
"\t\tfloat t = SampleDepth(normalMap, dp + ds * depth);\n"
"\t\t\n"
"\t\tif(depth >= t)\n"
"\t\t{\n"
"\t\t\tbestDepth = depth;\n"
"\t\t\tdepth -= 2.0 * size;\n"
"\t\t}\n"
"\n"
"\t\tdepth += size;\n"
"\t}\n"
"\n"
"\treturn bestDepth;\n"
"}\n"
"#endif\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, vec3 N, vec3 L, vec3 E, float NE, float NL, float shininess)\n"
"{\n"
"  #if defined(USE_OREN_NAYAR) || defined(USE_TRIACE_OREN_NAYAR)\n"
"\tfloat gamma = dot(E, L) - NE * NL;\n"
"\tfloat B = 2.22222 + 0.1 * shininess;\n"
"\t\t\n"
"    #if defined(USE_OREN_NAYAR)\n"
"\tfloat A = 1.0 - 1.0 / (2.0 + 0.33 * shininess);\n"
"\tgamma = clamp(gamma, 0.0, 1.0);\n"
"    #endif\n"
"\t\n"
"    #if defined(USE_TRIACE_OREN_NAYAR)\n"
"\tfloat A = 1.0 - 1.0 / (2.0 + 0.65 * shininess);\n"
"\n"
"\tif (gamma >= 0.0)\n"
"    #endif\n"
"\t{\n"
"\t\tB = max(B * max(NL, NE), EPSILON);\n"
"\t}\n"
"\n"
"\treturn diffuseAlbedo * (A + gamma / B);\n"
"  #else\n"
"\treturn diffuseAlbedo;\n"
"  #endif\n"
"}\n"
"\n"
"vec3 EnvironmentBRDF(float gloss, float NE, vec3 specular)\n"
"{\n"
"  #if 1\n"
"\t// from http://blog.selfshadow.com/publications/s2013-shading-course/lazarov/s2013_pbs_black_ops_2_notes.pdf\n"
"\tvec4 t = vec4( 1/0.96, 0.475, (0.0275 - 0.25 * 0.04)/0.96,0.25 ) * gloss;\n"
"\tt += vec4( 0.0, 0.0, (0.015 - 0.75 * 0.04)/0.96,0.75 );\n"
"\tfloat a0 = t.x * min( t.y, exp2( -9.28 * NE ) ) + t.z;\n"
"\tfloat a1 = t.w;\n"
"\treturn clamp( a0 + specular * ( a1 - a0 ), 0.0, 1.0 );\n"
"  #elif 0\n"
"    // from http://seblagarde.wordpress.com/2011/08/17/hello-world/\n"
"\treturn mix(specular.rgb, max(specular.rgb, vec3(gloss)), CalcFresnel(NE));\n"
"  #else\n"
"    // from http://advances.realtimerendering.com/s2011/Lazarov-Physically-Based-Lighting-in-Black-Ops%20%28Siggraph%202011%20Advances%20in%20Real-Time%20Rendering%20Course%29.pptx\n"
"\treturn mix(specular.rgb, vec3(1.0), CalcFresnel(NE) / (4.0 - 3.0 * gloss));\n"
"  #endif\n"
"}\n"
"\n"
"float CalcBlinn(float NH, float shininess)\n"
"{\n"
"#if 0\n"
"    // from http://seblagarde.wordpress.com/2012/06/03/spherical-gaussien-approximation-for-blinn-phong-phong-and-fresnel/\n"
"\tfloat a = shininess + 0.775;\n"
"    return exp(a * NH - a);\n"
"#else\n"
"\treturn pow(NH, shininess);\n"
"#endif\n"
"}\n"
"\n"
"float CalcGGX(float NH, float gloss)\n"
"{\n"
"\t// from http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n"
"\tfloat a_sq = exp2(gloss * -13.0 + 1.0);\n"
"\tfloat d = ((NH * NH) * (a_sq - 1.0) + 1.0);\n"
"\treturn a_sq / (d * d);\n"
"}\n"
"\n"
"float CalcFresnel(float EH)\n"
"{\n"
"#if 1\n"
"\t// From http://blog.selfshadow.com/publications/s2013-shading-course/lazarov/s2013_pbs_black_ops_2_notes.pdf\n"
"\t// not accurate, but fast\n"
"\treturn exp2(-10.0 * EH);\n"
"#elif 0\n"
"\t// From http://seblagarde.wordpress.com/2012/06/03/spherical-gaussien-approximation-for-blinn-phong-phong-and-fresnel/\n"
"\treturn exp2((-5.55473 * EH - 6.98316) * EH);\n"
"#elif 0\n"
"\tfloat blend = 1.0 - EH;\n"
"\tfloat blend2 = blend * blend;\n"
"\tblend *= blend2 * blend2;\n"
"\t\n"
"\treturn blend;\n"
"#else\n"
"\treturn pow(1.0 - EH, 5.0);\n"
"#endif\n"
"}\n"
"\n"
"float CalcVisibility(float NH, float NL, float NE, float EH, float gloss)\n"
"{\n"
"#if 1\n"
"\t// From http://blog.selfshadow.com/publications/s2013-shading-course/lazarov/s2013_pbs_black_ops_2_notes.pdf\n"
"\tfloat k = min(1.0, gloss + 0.545);\n"
"\treturn 1.0 / (k * EH * EH + (1.0 - k));\n"
"#elif 0\n"
"\tfloat roughness = exp2(gloss * -6.5);\n"
"\n"
"  #if defined(USE_GGX)\n"
"\t// From http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n"
"\tfloat k = roughness + 1.0;\n"
"\tk *= k * 0.125;\n"
"  #else\n"
"    float k = roughness;\n"
"  #endif\n"
"\t// Modified from http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n"
"\t// NL, NE in numerator factored out from cook-torrance\n"
"\tfloat k2 = 1.0 - k;\n"
"\t\n"
"\tfloat invGeo1 = NL * k2 + k;\n"
"\tfloat invGeo2 = NE * k2 + k;\n"
"\t\n"
"\treturn 1.0 / (invGeo1 * invGeo2);\n"
"#else\n"
"\tfloat geo = 2.0 * NH * min(NE, NL);\n"
"\tgeo /= max(EH, geo);\n"
"\t\n"
"\treturn geo;\n"
"#endif\n"
"}\n"
"\n"
"\n"
"vec3 CalcSpecular(vec3 specular, float NH, float NL, float NE, float EH, float gloss, float shininess)\n"
"{\n"
"\tfloat blinn = CalcBlinn(NH, shininess);\n"
"\tvec3 fSpecular = mix(specular, vec3(1.0), CalcFresnel(EH));\n"
"\tfloat vis = CalcVisibility(NH, NL, NE, EH, gloss);\n"
"\n"
"  #if defined(USE_BLINN)\n"
"    // Normalized Blinn-Phong\n"
"\treturn specular  * blinn * (shininess * 0.125    + 1.0);\n"
"  #elif defined(USE_BLINN_FRESNEL)\n"
"    // Normalized Blinn-Phong with Fresnel\n"
"\treturn fSpecular * blinn * (shininess * 0.125    + 1.0);\n"
"  #elif defined(USE_MCAULEY)\n"
"    // Cook-Torrance as done by Stephen McAuley\n"
"\t// http://blog.selfshadow.com/publications/s2012-shading-course/mcauley/s2012_pbs_farcry3_notes_v2.pdf\n"
"\treturn fSpecular * blinn * (shininess * 0.25     + 0.125);\n"
"  #elif defined(USE_GOTANDA)\n"
"    // Neumann-Neumann as done by Yoshiharu Gotanda\n"
"\t// http://research.tri-ace.com/Data/s2012_beyond_CourseNotes.pdf\n"
"\treturn fSpecular * blinn * (shininess * 0.124858 + 0.269182) / max(max(NL, NE), EPSILON);\n"
"  #elif defined(USE_LAZAROV)\n"
"    // Cook-Torrance as done by Dimitar Lazarov\n"
"\t// http://blog.selfshadow.com/publications/s2013-shading-course/lazarov/s2013_pbs_black_ops_2_notes.pdf\n"
"\treturn fSpecular * blinn * (shininess * 0.125    + 0.25)     * vis;\n"
"  #endif\n"
"  \n"
"\treturn vec3(0.0);\n"
"}\n"
"\n"
"\n"
"float CalcLightAttenuation(vec3 dir, float sqrRadius)\n"
"{\n"
"\t// point light at >0 radius, directional otherwise\n"
"\tfloat point = float(sqrRadius > 0.0);\n"
"\n"
"\t// inverse square light\n"
"\tfloat attenuation = sqrRadius / dot(dir, dir);\n"
"\n"
"\t// zero light at radius, approximating q3 style\n"
"\t// also don't attenuate directional light\n"
"\tattenuation = (0.5 * attenuation - 1.5) * point + 1.0;\n"
"\t\n"
"\t// clamp attenuation\n"
"\t#if defined(NO_LIGHT_CLAMP)\n"
"\tattenuation = max(attenuation, 0.0);\n"
"\t#else\n"
"\tattenuation = clamp(attenuation, 0.0, 1.0);\n"
"\t#endif\n"
"\t\n"
"\treturn attenuation;\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tvec3 L, N, E, H;\n"
"\tfloat NL, NH, NE, EH;\n"
"\t\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || defined(USE_PARALLAXMAP)\n"
"\tmat3 tangentToWorld = mat3(var_Tangent.xyz, var_Bitangent.xyz, var_Normal.xyz);\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"\tL = (2.0 * texture2D(u_DeluxeMap, var_TexCoords.zw).xyz - vec3(1.0));\n"
"  #if defined(USE_TANGENT_SPACE_LIGHT)\n"
"\tL = L * tangentToWorld;\n"
"  #endif\n"
"#elif defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"\tL = var_LightDir.xyz;\n"
"#endif\n"
"\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || defined(USE_PARALLAXMAP)\n"
"\tE = normalize(vec3(var_Normal.w, var_Tangent.w, var_Bitangent.w));\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"\tvec4 lightSample = texture2D(u_LightMap, var_TexCoords.zw).rgba;\n"
"  #if defined(RGBM_LIGHTMAP)\n"
"\tlightSample.rgb *= 32.0 * lightSample.a;\n"
"  #endif\n"
"\tvec3 lightColor = lightSample.rgb;\n"
"#elif defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT)\n"
"\tvec3 lightColor   = u_DirectedLight * CalcLightAttenuation(L, var_LightDir.w);\n"
"\tvec3 ambientColor = u_AmbientLight;\n"
"#elif defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)\n"
"\tvec3 lightColor = var_LightColor;\n"
"#endif\n"
"\n"
"\tvec2 texCoords = var_TexCoords.xy;\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"  #if defined(USE_TANGENT_SPACE_LIGHT)\n"
"\tvec3 offsetDir = E;\n"
"  #else\n"
"\tvec3 offsetDir = E * tangentToWorld;\n"
"  #endif\n"
"\n"
"\toffsetDir.xy *= -0.05 / offsetDir.z;\n"
"\n"
"\ttexCoords += offsetDir.xy * RayIntersectDisplaceMap(texCoords, offsetDir.xy, u_NormalMap);\n"
"#endif\n"
"\n"
"\tvec4 diffuse = texture2D(u_DiffuseMap, texCoords);\n"
"#if defined(USE_GAMMA2_TEXTURES)\n"
"\tdiffuse.rgb *= diffuse.rgb;\n"
"#endif\n"
"\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"  #if defined(USE_NORMALMAP)\n"
"    #if defined(SWIZZLE_NORMALMAP)\n"
"\tN.xy = 2.0 * texture2D(u_NormalMap, texCoords).ag - vec2(1.0);\n"
"    #else\n"
"\tN.xy = 2.0 * texture2D(u_NormalMap, texCoords).rg - vec2(1.0);\n"
"    #endif\n"
"\tN.z = sqrt(1.0 - clamp(dot(N.xy, N.xy), 0.0, 1.0));\n"
"    #if !defined(USE_TANGENT_SPACE_LIGHT)\n"
"    N = normalize(tangentToWorld * N);\n"
"    #endif\n"
"  #elif defined(USE_TANGENT_SPACE_LIGHT)\n"
"\tN = vec3(0.0, 0.0, 1.0);\n"
"  #else\n"
"    N = normalize(var_Normal.xyz);\n"
"  #endif\n"
"  \n"
"\tL = normalize(L);\n"
"\n"
"  #if defined(USE_SHADOWMAP) \n"
"\tvec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\n"
"\tfloat shadowValue = texture2D(u_ShadowMap, shadowTex).r;\n"
"\n"
"\t// surfaces not facing the light are always shadowed\n"
"\t#if defined(USE_TANGENT_SPACE_LIGHT)\n"
"\tshadowValue *= step(0.0, var_PrimaryLightDir.z);\n"
"\t#else\n"
"\tshadowValue *= step(0.0, dot(var_Normal.xyz, var_PrimaryLightDir.xyz));\n"
"\t#endif\n"
"  \n"
"    #if defined(SHADOWMAP_MODULATE)\n"
"\t//vec3 shadowColor = min(u_PrimaryLightAmbient, lightColor);\n"
"\tvec3 shadowColor = u_PrimaryLightAmbient * lightColor;\n"
"\n"
"      #if 0\n"
"\t// Only shadow when the world light is parallel to the primary light\n"
"\tshadowValue = 1.0 + (shadowValue - 1.0) * clamp(dot(L, var_PrimaryLightDir.xyz), 0.0, 1.0);\n"
"      #endif\n"
"\tlightColor = mix(shadowColor, lightColor, shadowValue);\n"
"    #endif\n"
"  #endif\n"
"\n"
"  #if defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)\n"
"\tvec3 ambientColor = lightColor;\n"
"\t\n"
"\t#if defined(USE_TANGENT_SPACE_LIGHT)\n"
"\tfloat surfNL = L.z;\n"
"\t#else\n"
"\tfloat surfNL = clamp(dot(var_Normal.xyz, L), 0.0, 1.0);\n"
"\t#endif\n"
"\n"
"\t// Scale the incoming light to compensate for the baked-in light angle\n"
"\t// attenuation.\n"
"\tlightColor /= max(surfNL, 0.25);\n"
"\n"
"\t// Recover any unused light as ambient, in case attenuation is over 4x or\n"
"\t// light is below the surface\n"
"\tambientColor -= lightColor * surfNL;\n"
"  #endif\n"
"  \n"
"\tvec3 reflectance;\n"
"\n"
"\tNL = clamp(dot(N, L), 0.0, 1.0);\n"
"\tNE = clamp(dot(N, E), 0.0, 1.0);\n"
"\n"
"  #if defined(USE_SPECULARMAP)\n"
"\tvec4 specular = texture2D(u_SpecularMap, texCoords);\n"
"    #if defined(USE_GAMMA2_TEXTURES)\n"
"\tspecular.rgb *= specular.rgb;\n"
"    #endif\n"
"  #else\n"
"\tvec4 specular = vec4(1.0);\n"
"  #endif\n"
"\n"
"\tspecular *= u_MaterialInfo.xxxy;\n"
"\t\n"
"\tfloat gloss = specular.a;\n"
"\tfloat shininess = exp2(gloss * 13.0);\n"
"\n"
"  #if defined(SPECULAR_IS_METALLIC)\n"
"    // diffuse is actually base color, and red of specular is metallicness\n"
"\tfloat metallic = specular.r;\n"
"\t\n"
"\tspecular.rgb = vec3(0.04) + 0.96 * diffuse.rgb * metallic;\n"
"\tdiffuse.rgb *= 1.0 - metallic;\n"
"  #else\n"
"\t// adjust diffuse by specular reflectance, to maintain energy conservation\n"
"\tdiffuse.rgb *= vec3(1.0) - specular.rgb;\n"
"  #endif\n"
"  \n"
"\t\n"
"\treflectance = CalcDiffuse(diffuse.rgb, N, L, E, NE, NL, shininess);\n"
"\n"
"  #if defined(r_deluxeSpecular) || defined(USE_LIGHT_VECTOR)\n"
"\tfloat adjGloss = gloss;\n"
"\tfloat adjShininess = shininess;\n"
"\t\n"
"\t#if !defined(USE_LIGHT_VECTOR)\n"
"\tadjGloss *= r_deluxeSpecular;\n"
"\tadjShininess = exp2(adjGloss * 13.0);\n"
"\t#endif\n"
"\t\n"
"\tH = normalize(L + E);\n"
"\n"
"\tEH = clamp(dot(E, H), 0.0, 1.0);\n"
"\tNH = clamp(dot(N, H), 0.0, 1.0);\n"
"\n"
"    #if !defined(USE_LIGHT_VECTOR)\n"
"\treflectance += CalcSpecular(specular.rgb, NH, NL, NE, EH, adjGloss, adjShininess) * r_deluxeSpecular;\n"
"    #else\n"
"\treflectance += CalcSpecular(specular.rgb, NH, NL, NE, EH, adjGloss, adjShininess);\n"
"    #endif\n"
"  #endif\n"
"\t\n"
"\tgl_FragColor.rgb  = lightColor   * reflectance * NL;  \n"
"\tgl_FragColor.rgb += ambientColor * (diffuse.rgb + specular.rgb);\n"
"\t\n"
"  #if defined(USE_CUBEMAP)\n"
"\treflectance = EnvironmentBRDF(gloss, NE, specular.rgb);\n"
"\n"
"\tvec3 R = reflect(E, N);\n"
"\t#if defined(USE_TANGENT_SPACE_LIGHT)\n"
"\tR = tangentToWorld * R;\n"
"\t#endif\n"
"\n"
"    vec3 cubeLightColor = textureCubeLod(u_CubeMap, R, 7.0 - gloss * 7.0).rgb;\n"
"\n"
"\t#if defined(USE_LIGHTMAP)\n"
"\tcubeLightColor *= lightSample.rgb;\n"
"\t#elif defined (USE_LIGHT_VERTEX)\n"
"\tcubeLightColor *= var_LightColor;\n"
"\t#else\n"
"\tcubeLightColor *= lightColor * NL + ambientColor;\n"
"\t#endif\n"
"\t\n"
"\t//gl_FragColor.rgb += diffuse.rgb * textureCubeLod(u_CubeMap, N, 7.0).rgb;\n"
"\tgl_FragColor.rgb += cubeLightColor * reflectance;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PRIMARY_LIGHT)\n"
"\tL = var_PrimaryLightDir.xyz; //normalize(var_PrimaryLightDir.xyz);\n"
"\tNL = clamp(dot(N, L), 0.0, 1.0);\n"
"\n"
"\tH = normalize(L + E);\n"
"\tEH = clamp(dot(E, H), 0.0, 1.0);\n"
"\tNH = clamp(dot(N, H), 0.0, 1.0);\n"
"\n"
"\treflectance  = CalcDiffuse(diffuse.rgb, N, L, E, NE, NL, shininess);\n"
"\treflectance += CalcSpecular(specular.rgb, NH, NL, NE, EH, gloss, shininess);\n"
"\n"
"\tlightColor = u_PrimaryLightColor; // * CalcLightAttenuation(L, u_PrimaryLightDir.w);\n"
"\t\n"
"    #if defined(USE_SHADOWMAP)\n"
"\tlightColor *= shadowValue;\n"
"    #endif\n"
"\n"
"\tgl_FragColor.rgb += lightColor * reflectance * NL;\n"
"  #endif\n"
"\n"
"\tgl_FragColor.a = diffuse.a;\n"
"#else\n"
"\tgl_FragColor = diffuse;\n"
"  #if defined(USE_LIGHTMAP) \n"
"\tgl_FragColor.rgb *= lightColor;\n"
"  #endif\n"
"#endif\n"
"\n"
"\tgl_FragColor *= var_Color;\n"
"}\n"
;
const char *fallbackShader_lightall_vp =
"attribute vec4 attr_TexCoord0;\n"
"#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)\n"
"attribute vec4 attr_TexCoord1;\n"
"#endif\n"
"attribute vec4 attr_Color;\n"
"\n"
"attribute vec3 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"attribute vec3 attr_Tangent;\n"
"attribute vec3 attr_Bitangent;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec3 attr_Position2;\n"
"attribute vec3 attr_Normal2;\n"
"attribute vec3 attr_Tangent2;\n"
"attribute vec3 attr_Bitangent2;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"attribute vec4 attr_BoneIndexes;\n"
"attribute vec4 attr_BoneWeights;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_LIGHT_VECTOR)\n"
"attribute vec3 attr_LightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_NORMALMAP) || defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"uniform vec3   u_ViewOrigin;\n"
"uniform vec3   u_LocalViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int    u_TCGen0;\n"
"uniform vec3   u_TCGen0Vector0;\n"
"uniform vec3   u_TCGen0Vector1;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"uniform vec4   u_DiffuseTexMatrix;\n"
"uniform vec4   u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"uniform vec4   u_BaseColor;\n"
"uniform vec4   u_VertColor;\n"
"\n"
"#if defined(USE_MODELMATRIX)\n"
"uniform mat4   u_ModelMatrix;\n"
"#endif\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float  u_VertexLerp;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"uniform mat4   u_BoneMatrices[80];\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"uniform vec4   u_LightOrigin;\n"
"uniform float  u_LightRadius;\n"
"uniform vec3   u_DirectedLight;\n"
"  #if defined(USE_FAST_LIGHT)\n"
"uniform vec3   u_AmbientLight;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec4  u_PrimaryLightOrigin;\n"
"uniform float u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"varying vec4   var_TexCoords;\n"
"\n"
"varying vec4   var_Color;\n"
"\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || defined(USE_PARALLAXMAP)\n"
"varying vec4   var_Normal;\n"
"varying vec4   var_Tangent;\n"
"varying vec4   var_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)\n"
"varying vec3   var_LightColor;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)\n"
"varying vec4   var_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"varying vec4   var_PrimaryLightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"\tvec2 tex = attr_TexCoord0.st;\n"
"\n"
"\tif (TCGen == TCGEN_LIGHTMAP)\n"
"\t{\n"
"\t\ttex = attr_TexCoord1.st;\n"
"\t}\n"
"\telse if (TCGen == TCGEN_ENVIRONMENT_MAPPED)\n"
"\t{\n"
"\t\tvec3 viewer = normalize(u_LocalViewOrigin - position);\n"
"\t\ttex = -reflect(viewer, normal).yz * vec2(0.5, -0.5) + 0.5;\n"
"\t}\n"
"\telse if (TCGen == TCGEN_VECTOR)\n"
"\t{\n"
"\t\ttex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"\t}\n"
"\t\n"
"\treturn tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"\tfloat amplitude = offTurb.z;\n"
"\tfloat phase = offTurb.w;\n"
"\tvec2 st2 = vec2(dot(st, texMatrix.xz), dot(st, texMatrix.yw)) + offTurb.xy;\n"
"\n"
"\tvec3 offsetPos = position / 1024.0;\n"
"\toffsetPos.x += offsetPos.z;\n"
"\t\n"
"\tvec2 texOffset = sin((offsetPos.xy + vec2(phase)) * 2.0 * M_PI);\n"
"\t\n"
"\treturn st2 + texOffset * amplitude;\t\n"
"}\n"
"#endif\n"
"\n"
"\n"
"float CalcLightAttenuation(vec3 dir, float sqrRadius)\n"
"{\n"
"\t// point light at >0 radius, directional otherwise\n"
"\tfloat point = float(sqrRadius > 0.0);\n"
"\n"
"\t// inverse square light\n"
"\tfloat attenuation = sqrRadius / dot(dir, dir);\n"
"\n"
"\t// zero light at radius, approximating q3 style\n"
"\t// also don't attenuate directional light\n"
"\tattenuation = (0.5 * attenuation - 1.5) * point + 1.0;\n"
"\t\n"
"\t// clamp attenuation\n"
"\t#if defined(NO_LIGHT_CLAMP)\n"
"\tattenuation = max(attenuation, 0.0);\n"
"\t#else\n"
"\tattenuation = clamp(attenuation, 0.0, 1.0);\n"
"\t#endif\n"
"\t\n"
"\treturn attenuation;\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"\tvec3 position  = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"\tvec3 normal    = normalize(mix(attr_Normal,    attr_Normal2,    u_VertexLerp));\n"
"\tvec3 tangent   = normalize(mix(attr_Tangent,   attr_Tangent2,   u_VertexLerp));\n"
"\tvec3 bitangent = normalize(mix(attr_Bitangent, attr_Bitangent2, u_VertexLerp));\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"\tvec4 position4 = vec4(0.0);\n"
"\tvec4 normal4 = vec4(0.0);\n"
"\tvec4 tangent4 = vec4(0.0);\n"
"\tvec4 bitangent4 = vec4(0.0);\n"
"\tvec4 originalPosition = vec4(attr_Position, 1.0);\n"
"\tvec4 originalNormal = vec4(attr_Normal, 0.0);\n"
"\tvec4 originalTangent = vec4(attr_Tangent, 0.0);\n"
"\tvec4 originalBitangent = vec4(attr_Bitangent, 0.0);\n"
"\tfor (int i = 0; i < 4; i++) {\n"
"\t\tint boneIndex = int(attr_BoneIndexes[i]);\n"
"\n"
"\t\tposition4 += (u_BoneMatrices[boneIndex] * originalPosition) * attr_BoneWeights[i];\n"
"\t\tnormal4 += (u_BoneMatrices[boneIndex] * originalNormal) * attr_BoneWeights[i];\n"
"\t\ttangent4 += (u_BoneMatrices[boneIndex] * originalTangent) * attr_BoneWeights[i];\n"
"\t\tbitangent4 += (u_BoneMatrices[boneIndex] * originalBitangent) * attr_BoneWeights[i];\n"
"\t}\n"
"\tvec3 position = position4.xyz;\n"
"\tvec3 normal = normal4.xyz;\n"
"\tvec3 tangent = tangent4.xyz;\n"
"\tvec3 bitangent = bitangent4.xyz;\n"
"#else\n"
"\tvec3 position  = attr_Position;\n"
"\tvec3 normal    = attr_Normal;\n"
"\tvec3 tangent   = attr_Tangent;\n"
"\tvec3 bitangent = attr_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"\tvec2 texCoords = GenTexCoords(u_TCGen0, position, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"\tvec2 texCoords = attr_TexCoord0.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"\tvar_TexCoords.xy = ModTexCoords(texCoords, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"\tvar_TexCoords.xy = texCoords;\n"
"#endif\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"#if defined(USE_MODELMATRIX)\n"
"\tposition  = (u_ModelMatrix * vec4(position,  1.0)).xyz;\n"
"\tnormal    = (u_ModelMatrix * vec4(normal,    0.0)).xyz;\n"
"\ttangent   = (u_ModelMatrix * vec4(tangent,   0.0)).xyz;\n"
"\tbitangent = (u_ModelMatrix * vec4(bitangent, 0.0)).xyz;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"\tvec3 L = u_LightOrigin.xyz - (position * u_LightOrigin.w);\n"
"#elif defined(USE_LIGHT) && !defined(USE_DELUXEMAP)\n"
"\tvec3 L = attr_LightDirection;\n"
"  #if defined(USE_MODELMATRIX)\n"
"\tL = (u_ModelMatrix * vec4(L, 0.0)).xyz;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"\tvar_TexCoords.zw = attr_TexCoord1.st;\n"
"#endif\n"
"\t\n"
"\tvar_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"#if defined(USE_LIGHT_VERTEX) && !defined(USE_FAST_LIGHT)\n"
"\tvar_LightColor = var_Color.rgb;\n"
"\tvar_Color.rgb = vec3(1.0);\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR) && defined(USE_FAST_LIGHT)\n"
"\tfloat attenuation = CalcLightAttenuation(L, u_LightRadius * u_LightRadius);\n"
"\tfloat NL = clamp(dot(normal, normalize(L)), 0.0, 1.0);\n"
"\n"
"\tvar_Color.rgb *= u_DirectedLight * attenuation * NL + u_AmbientLight;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"\tvar_PrimaryLightDir.xyz = u_PrimaryLightOrigin.xyz - (position * u_PrimaryLightOrigin.w);\n"
"\tvar_PrimaryLightDir.w = u_PrimaryLightRadius * u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"\tvar_LightDir = vec4(L, u_LightRadius * u_LightRadius);\n"
"  #else\n"
"\tvar_LightDir = vec4(L, 0.0);\n"
"  #endif\n"
"#endif\n"
"\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || defined(USE_PARALLAXMAP)\n"
"\tvec3 viewDir = u_ViewOrigin - position;\n"
"#endif\n"
"\n"
"#if defined(USE_TANGENT_SPACE_LIGHT)\n"
"\tmat3 tangentToWorld = mat3(tangent, bitangent, normal);\n"
"\n"
"  #if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"\tvar_PrimaryLightDir.xyz = var_PrimaryLightDir.xyz * tangentToWorld;\n"
"  #endif\n"
"  \n"
"  #if defined(USE_LIGHT) && !defined(USE_DELUXEMAP) && !defined(USE_FAST_LIGHT)\n"
"\tvar_LightDir.xyz = var_LightDir.xyz * tangentToWorld;\n"
"  #endif\n"
"\n"
"  #if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || defined(USE_PARALLAXMAP)\n"
"\tviewDir = viewDir * tangentToWorld;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if (defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)) || defined(USE_PARALLAXMAP)\n"
"\t// store view direction in tangent space to save on varyings\n"
"\tvar_Normal    = vec4(normal,    viewDir.x);\n"
"\tvar_Tangent   = vec4(tangent,   viewDir.y);\n"
"\tvar_Bitangent = vec4(bitangent, viewDir.z);\n"
"#endif\n"
"}\n"
;
const char *fallbackShader_pshadow_fp =
"uniform sampler2D u_ShadowMap;\n"
"\n"
"uniform vec3      u_LightForward;\n"
"uniform vec3      u_LightUp;\n"
"uniform vec3      u_LightRight;\n"
"uniform vec4      u_LightOrigin;\n"
"uniform float     u_LightRadius;\n"
"varying vec3      var_Position;\n"
"varying vec3      var_Normal;\n"
"\n"
"float sampleDistMap(sampler2D texMap, vec2 uv, float scale)\n"
"{\n"
"\tvec3 distv = texture2D(texMap, uv).xyz;\n"
"\treturn dot(distv, vec3(1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0)) * scale;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tvec3 lightToPos = var_Position - u_LightOrigin.xyz;\n"
"\tvec2 st = vec2(-dot(u_LightRight, lightToPos), dot(u_LightUp, lightToPos));\n"
"\t\n"
"\tfloat fade = length(st);\n"
"\t\n"
"#if defined(USE_DISCARD)\n"
"\tif (fade >= 1.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"#endif\n"
"\n"
"\tfade = clamp(8.0 - fade * 8.0, 0.0, 1.0);\n"
"\t\n"
"\tst = st * 0.5 + vec2(0.5);\n"
"\n"
"#if defined(USE_SOLID_PSHADOWS)\n"
"\tfloat intensity = max(sign(u_LightRadius - length(lightToPos)), 0.0);\n"
"#else\n"
"\tfloat intensity = clamp((1.0 - dot(lightToPos, lightToPos) / (u_LightRadius * u_LightRadius)) * 2.0, 0.0, 1.0);\n"
"#endif\n"
"\t\n"
"\tfloat lightDist = length(lightToPos);\n"
"\tfloat dist;\n"
"\n"
"#if defined(USE_DISCARD)\n"
"\tif (dot(u_LightForward, lightToPos) <= 0.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"\n"
"\tif (dot(var_Normal, lightToPos) > 0.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"#else\n"
"\tintensity *= max(sign(dot(u_LightForward, lightToPos)), 0.0);\n"
"\tintensity *= max(sign(-dot(var_Normal, lightToPos)), 0.0);\n"
"#endif\n"
"\n"
"\tintensity *= fade;\n"
"#if defined(USE_PCF)\n"
"\tfloat part;\n"
"\t\n"
"\tdist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/512.0, -1.0/512.0), u_LightRadius);\n"
"\tpart =  max(sign(lightDist - dist), 0.0);\n"
"\n"
"\tdist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0, -1.0/512.0), u_LightRadius);\n"
"\tpart += max(sign(lightDist - dist), 0.0);\n"
"\n"
"\tdist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/512.0,  1.0/512.0), u_LightRadius);\n"
"\tpart += max(sign(lightDist - dist), 0.0);\n"
"\n"
"\tdist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0,  1.0/512.0), u_LightRadius);\n"
"\tpart += max(sign(lightDist - dist), 0.0);\n"
"\n"
"  #if defined(USE_DISCARD)\n"
"\tif (part <= 0.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"  #endif\n"
"\n"
"\tintensity *= part * 0.25;\n"
"#else\n"
"\tdist = sampleDistMap(u_ShadowMap, st, u_LightRadius);\n"
"\n"
"  #if defined(USE_DISCARD)\n"
"\tif (lightDist - dist <= 0.0)\n"
"\t{\n"
"\t\tdiscard;\n"
"\t}\n"
"  #endif\n"
"\t\t\t\n"
"\tintensity *= max(sign(lightDist - dist), 0.0);\n"
"#endif\n"
"\t\t\n"
"\tgl_FragColor.rgb = vec3(0);\n"
"\tgl_FragColor.a = clamp(intensity, 0.0, 0.75);\n"
"}\n"
;
const char *fallbackShader_pshadow_vp =
"attribute vec4 attr_Position;\n"
"attribute vec3 attr_Normal;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"varying vec3   var_Position;\n"
"varying vec3   var_Normal;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 position  = attr_Position;\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\n"
"\tvar_Position  = position.xyz;\n"
"\tvar_Normal    = attr_Normal;\n"
"}\n"
;
const char *fallbackShader_shadowfill_fp =
"uniform vec4  u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"\n"
"varying vec3  var_Position;\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_DEPTH)\n"
"\tfloat depth = length(u_LightOrigin.xyz - var_Position) / u_LightRadius;\n"
" #if 0\n"
"\t// 32 bit precision\n"
"\tconst vec4 bitSh = vec4( 256 * 256 * 256,   256 * 256,         256,           1);\n"
"\tconst vec4 bitMsk = vec4(              0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n"
"\t\n"
"\tvec4 comp;\n"
"\tcomp = depth * bitSh;\n"
"\tcomp.xyz = fract(comp.xyz);\n"
"\tcomp -= comp.xxyz * bitMsk;\n"
"\tgl_FragColor = comp;\n"
" #endif\n"
"\n"
" #if 1\n"
"\t// 24 bit precision\n"
"\tconst vec3 bitSh = vec3( 256 * 256,         256,           1);\n"
"\tconst vec3 bitMsk = vec3(        0, 1.0 / 256.0, 1.0 / 256.0);\n"
"\t\n"
"\tvec3 comp;\n"
"\tcomp = depth * bitSh;\n"
"\tcomp.xy = fract(comp.xy);\n"
"\tcomp -= comp.xxy * bitMsk;\n"
"\tgl_FragColor = vec4(comp, 1.0);\n"
" #endif\n"
"\n"
" #if 0\n"
"\t// 8 bit precision\n"
"\tgl_FragColor = vec4(depth, depth, depth, 1);\n"
" #endif\n"
"#else\n"
"\tgl_FragColor = vec4(0, 0, 0, 1);\n"
"#endif\n"
"}\n"
;
const char *fallbackShader_shadowfill_vp =
"attribute vec4  attr_Position;\n"
"attribute vec3  attr_Normal;\n"
"attribute vec4  attr_TexCoord0;\n"
"\n"
"//#if defined(USE_VERTEX_ANIMATION)\n"
"attribute vec4  attr_Position2;\n"
"attribute vec3  attr_Normal2;\n"
"//#endif\n"
"\n"
"//#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int     u_DeformGen;\n"
"uniform float    u_DeformParams[5];\n"
"//#endif\n"
"\n"
"uniform float   u_Time;\n"
"uniform mat4    u_ModelViewProjectionMatrix;\n"
"\n"
"uniform mat4   u_ModelMatrix;\n"
"\n"
"//#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float   u_VertexLerp;\n"
"//#endif\n"
"\n"
"varying vec3    var_Position;\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"\tif (u_DeformGen == 0)\n"
"\t{\n"
"\t\treturn pos;\n"
"\t}\n"
"\n"
"\tfloat base =      u_DeformParams[0];\n"
"\tfloat amplitude = u_DeformParams[1];\n"
"\tfloat phase =     u_DeformParams[2];\n"
"\tfloat frequency = u_DeformParams[3];\n"
"\tfloat spread =    u_DeformParams[4];\n"
"\n"
"\tif (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tphase *= M_PI * 0.25 * st.x;\n"
"\t}\n"
"\telse // if (u_DeformGen <= DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tphase += dot(pos.xyz, vec3(spread));\n"
"\t}\n"
"\n"
"\tfloat value = phase + (u_Time * frequency);\n"
"\tfloat func;\n"
"\n"
"\tif (u_DeformGen == DGEN_WAVE_SIN)\n"
"\t{\n"
"\t\tfunc = sin(value * 2.0 * M_PI);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SQUARE)\n"
"\t{\n"
"\t\tfunc = sign(sin(value * 2.0 * M_PI));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_TRIANGLE)\n"
"\t{\n"
"\t\tfunc = abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = fract(value);\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_WAVE_INVERSE_SAWTOOTH)\n"
"\t{\n"
"\t\tfunc = (1.0 - fract(value));\n"
"\t}\n"
"\telse if (u_DeformGen == DGEN_BULGE)\n"
"\t{\n"
"\t\tfunc = sin(value);\n"
"\t}\n"
"\n"
"\treturn pos + normal * (base + func * amplitude);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 position = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"\tvec3 normal = normalize(mix(attr_Normal, attr_Normal2, u_VertexLerp));\n"
"\n"
"\tposition.xyz = DeformPosition(position.xyz, normal, attr_TexCoord0.st);\n"
"\n"
"\tgl_Position = u_ModelViewProjectionMatrix * position;\n"
"\t\n"
"\tvar_Position  = (u_ModelMatrix * position).xyz;\n"
"}\n"
;
const char *fallbackShader_shadowmask_fp =
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform sampler2D u_ShadowMap;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform sampler2D u_ShadowMap2;\n"
"uniform sampler2D u_ShadowMap3;\n"
"#endif\n"
"\n"
"uniform mat4      u_ShadowMvp;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform mat4      u_ShadowMvp2;\n"
"uniform mat4      u_ShadowMvp3;\n"
"#endif\n"
"\n"
"uniform vec3   u_ViewOrigin;\n"
"uniform vec4   u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"varying vec2   var_DepthTex;\n"
"varying vec3   var_ViewDir;\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  \n"
"}\n"
"\n"
"float PCF(const sampler2D shadowmap, const vec2 st, const float dist)\n"
"{\n"
"\tfloat mult;\n"
"\tfloat scale = 2.0 / r_shadowMapSize;\n"
"\t\t\n"
"#if defined(USE_SHADOW_FILTER)\n"
"\tfloat r = random(var_DepthTex.xy);\n"
"\tfloat sinr = sin(r) * scale;\n"
"\tfloat cosr = cos(r) * scale;\n"
"\tmat2 rmat = mat2(cosr, sinr, -sinr, cosr);\n"
"\n"
"\tmult =  step(dist, texture2D(shadowmap, st + rmat * vec2(-0.7055767, 0.196515)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.3524343, -0.7791386)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.2391056, 0.9189604)).r);\n"
"  #if defined(USE_SHADOW_FILTER2)\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(-0.07580382, -0.09224417)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.5784913, -0.002528916)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.192888, 0.4064181)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(-0.6335801, -0.5247476)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(-0.5579782, 0.7491854)).r);\n"
"\tmult += step(dist, texture2D(shadowmap, st + rmat * vec2(0.7320465, 0.6317794)).r);\n"
"\n"
"\tmult *= 0.11111;\n"
"  #else\n"
"    mult *= 0.33333;\n"
"  #endif\n"
"#else\n"
"\tmult = step(dist, texture2D(shadowmap, st).r);\n"
"#endif\n"
"\t\t\n"
"\treturn mult;\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, vec2 tex, float zFarDivZNear)\n"
"{\n"
"\t\tfloat sampleZDivW = texture2D(depthMap, tex).r;\n"
"\t\treturn 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tfloat result;\n"
"\t\n"
"\tfloat depth = getLinearDepth(u_ScreenDepthMap, var_DepthTex, u_ViewInfo.x);\n"
"\tfloat sampleZ = u_ViewInfo.y * depth;\n"
"\n"
"\tvec4 biasPos = vec4(u_ViewOrigin + var_ViewDir * depth * 0.99, 1.0);\n"
"\t\n"
"\tvec4 shadowpos = u_ShadowMvp * biasPos;\n"
"\t\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"\tconst float fadeTo = 1.0;\n"
"\tresult = fadeTo;\n"
"#else\n"
"\tresult = 0.0;\n"
"#endif\n"
"\n"
"\tif (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"\t{\n"
"\t\tshadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\n"
"\t\tresult = PCF(u_ShadowMap, shadowpos.xy, shadowpos.z);\n"
"\t}\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"\telse\n"
"\t{\n"
"\t\tshadowpos = u_ShadowMvp2 * biasPos;\n"
"\n"
"\t\tif (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"\t\t{\n"
"\t\t\tshadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\n"
"\t\t\tresult = PCF(u_ShadowMap2, shadowpos.xy, shadowpos.z);\n"
"\t\t}\n"
"\t\telse\n"
"\t\t{\n"
"\t\t\tshadowpos = u_ShadowMvp3 * biasPos;\n"
"\n"
"\t\t\tif (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"\t\t\t{\n"
"\t\t\t\tshadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\n"
"\t\t\t\tresult = PCF(u_ShadowMap3, shadowpos.xy, shadowpos.z);\n"
"\n"
"\t\t\t\tfloat fade = clamp(sampleZ / r_shadowCascadeZFar * 10.0 - 9.0, 0.0, 1.0);\n"
"\t\t\t\tresult = mix(result, fadeTo, fade);\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"#endif\n"
"\t\t\n"
"\tgl_FragColor = vec4(vec3(result), 1.0);\n"
"}\n"
;
const char *fallbackShader_shadowmask_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform vec3   u_ViewForward;\n"
"uniform vec3   u_ViewLeft;\n"
"uniform vec3   u_ViewUp;\n"
"uniform vec4   u_ViewInfo; // zfar / znear\n"
"\n"
"varying vec2   var_DepthTex;\n"
"varying vec3   var_ViewDir;\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = attr_Position;\n"
"\tvec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"\tvar_DepthTex = attr_TexCoord0.xy;\n"
"\tvar_ViewDir = u_ViewForward + u_ViewLeft * -screenCoords.x + u_ViewUp * screenCoords.y;\n"
"}\n"
;
const char *fallbackShader_ssao_fp =
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform vec4   u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"varying vec2   var_ScreenTex;\n"
"\n"
"vec2 poissonDisc[9] = vec2[9](\n"
"vec2(-0.7055767, 0.196515),    vec2(0.3524343, -0.7791386),\n"
"vec2(0.2391056, 0.9189604),    vec2(-0.07580382, -0.09224417),\n"
"vec2(0.5784913, -0.002528916), vec2(0.192888, 0.4064181),\n"
"vec2(-0.6335801, -0.5247476),  vec2(-0.5579782, 0.7491854),\n"
"vec2(0.7320465, 0.6317794)\n"
");\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  \n"
"}\n"
"\n"
"mat2 randomRotation( const vec2 p )\n"
"{\n"
"\tfloat r = random(p);\n"
"\tfloat sinr = sin(r);\n"
"\tfloat cosr = cos(r);\n"
"\treturn mat2(cosr, sinr, -sinr, cosr);\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"\t\tfloat sampleZDivW = texture2D(depthMap, tex).r;\n"
"\t\treturn 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"float ambientOcclusion(sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const float zFar)\n"
"{\n"
"\tfloat result = 0;\n"
"\n"
"\tfloat sampleZ = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"\n"
"\tvec2 expectedSlope = vec2(dFdx(sampleZ), dFdy(sampleZ)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"\t\n"
"\tif (length(expectedSlope) > 5000.0)\n"
"\t\treturn 1.0;\n"
"\t\n"
"\tvec2 offsetScale = vec2(3.0 / sampleZ);\n"
"\t\n"
"\tmat2 rmat = randomRotation(tex);\n"
"\t\t\n"
"\tint i;\n"
"\tfor (i = 0; i < 3; i++)\n"
"\t{\n"
"\t\tvec2 offset = rmat * poissonDisc[i] * offsetScale;\n"
"\t\tfloat sampleZ2 = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"\n"
"\t\tif (abs(sampleZ - sampleZ2) > 20.0)\n"
"\t\t\tresult += 1.0;\n"
"\t\telse\n"
"\t\t{\n"
"\t\t\tfloat expectedZ = sampleZ + dot(expectedSlope, offset);\n"
"\t\t\tresult += step(expectedZ - 1.0, sampleZ2);\n"
"\t\t}\n"
"\t}\n"
"\t\n"
"\tresult *= 0.33333;\n"
"\t\n"
"\treturn result;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tfloat result = ambientOcclusion(u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);\n"
"\t\t\t\n"
"\tgl_FragColor = vec4(vec3(result), 1.0);\n"
"}\n"
;
const char *fallbackShader_ssao_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"varying vec2   var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = attr_Position;\n"
"\tvar_ScreenTex = attr_TexCoord0.xy;\n"
"\t//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"\t//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
;
const char *fallbackShader_texturecolor_fp =
"#version 120\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"uniform vec4      u_Color;\n"
"\n"
"varying vec2         var_Tex1;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_FragColor = texture2D(u_DiffuseMap, var_Tex1) * u_Color;\n"
"}\n"
;
const char *fallbackShader_texturecolor_vp =
"#version 120\n"
"\n"
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_Tex1;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_Tex1 = attr_TexCoord0.st;\n"
"}\n"
;
const char *fallbackShader_tonemap_fp =
"uniform sampler2D u_TextureMap;\n"
"uniform sampler2D u_LevelsMap;\n"
"\n"
"uniform vec4      u_Color;\n"
"\n"
"uniform vec2      u_AutoExposureMinMax;\n"
"uniform vec3      u_ToneMinAvgMaxLinear;\n"
"\n"
"varying vec2      var_TexCoords;\n"
"\n"
"const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 FilmicTonemap(vec3 x)\n"
"{\n"
"\tconst float SS  = 0.22; // Shoulder Strength\n"
"\tconst float LS  = 0.30; // Linear Strength\n"
"\tconst float LA  = 0.10; // Linear Angle\n"
"\tconst float TS  = 0.20; // Toe Strength\n"
"\tconst float TAN = 0.01; // Toe Angle Numerator\n"
"\tconst float TAD = 0.30; // Toe Angle Denominator\n"
"\t\n"
"\tvec3 SSxx = SS * x * x;\n"
"\tvec3 LSx = LS * x;\n"
"\tvec3 LALSx = LSx * LA;\n"
"\t\n"
"\treturn ((SSxx + LALSx + TS * TAN) / (SSxx + LSx + TS * TAD)) - TAN / TAD;\n"
"\n"
"\t//return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"\tvec4 color = texture2D(u_TextureMap, var_TexCoords) * u_Color;\n"
"\tvec3 minAvgMax = texture2D(u_LevelsMap, var_TexCoords).rgb;\n"
"\tvec3 logMinAvgMaxLum = clamp(minAvgMax * 20.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x);\n"
"\t\t\n"
"\tfloat avgLum = exp2(logMinAvgMaxLum.y);\n"
"\t//float maxLum = exp2(logMinAvgMaxLum.z);\n"
"\n"
"\tcolor.rgb *= u_ToneMinAvgMaxLinear.y / avgLum;\n"
"\tcolor.rgb = max(vec3(0.0), color.rgb - vec3(u_ToneMinAvgMaxLinear.x));\n"
"\n"
"\tvec3 fWhite = 1.0 / FilmicTonemap(vec3(u_ToneMinAvgMaxLinear.z - u_ToneMinAvgMaxLinear.x));\n"
"\tcolor.rgb = FilmicTonemap(color.rgb) * fWhite;\n"
"\t\n"
"\tgl_FragColor = clamp(color, 0.0, 1.0);\n"
"}\n"
;
const char *fallbackShader_tonemap_vp =
"attribute vec4 attr_Position;\n"
"attribute vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4   u_ModelViewProjectionMatrix;\n"
"\n"
"varying vec2   var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = u_ModelViewProjectionMatrix * attr_Position;\n"
"\tvar_TexCoords = attr_TexCoord0.st;\n"
"}\n"
;